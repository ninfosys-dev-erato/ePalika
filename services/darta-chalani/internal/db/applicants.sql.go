// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: applicants.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const countApplicants = `-- name: CountApplicants :one
SELECT COUNT(*) FROM applicants
WHERE
    ($1::VARCHAR IS NULL OR type = $1)
    AND ($2::TEXT IS NULL OR 
         full_name ILIKE '%' || $2 || '%' OR
         organization ILIKE '%' || $2 || '%')
`

type CountApplicantsParams struct {
	Type   *string `json:"type"`
	Search *string `json:"search"`
}

func (q *Queries) CountApplicants(ctx context.Context, arg CountApplicantsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countApplicants, arg.Type, arg.Search)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createApplicant = `-- name: CreateApplicant :one

INSERT INTO applicants (
    type,
    full_name,
    organization,
    email,
    phone,
    address,
    identification_number
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, type, full_name, organization, email, phone, address, identification_number, created_at, updated_at
`

type CreateApplicantParams struct {
	Type                 string  `json:"type"`
	FullName             string  `json:"full_name"`
	Organization         *string `json:"organization"`
	Email                *string `json:"email"`
	Phone                *string `json:"phone"`
	Address              *string `json:"address"`
	IdentificationNumber *string `json:"identification_number"`
}

// ============================================================================
// APPLICANTS - People/Organizations submitting darta
// ============================================================================
func (q *Queries) CreateApplicant(ctx context.Context, arg CreateApplicantParams) (Applicant, error) {
	row := q.db.QueryRow(ctx, createApplicant,
		arg.Type,
		arg.FullName,
		arg.Organization,
		arg.Email,
		arg.Phone,
		arg.Address,
		arg.IdentificationNumber,
	)
	var i Applicant
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.FullName,
		&i.Organization,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.IdentificationNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteApplicant = `-- name: DeleteApplicant :exec
DELETE FROM applicants WHERE id = $1
`

func (q *Queries) DeleteApplicant(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteApplicant, id)
	return err
}

const findApplicantByIdentification = `-- name: FindApplicantByIdentification :one
SELECT id, type, full_name, organization, email, phone, address, identification_number, created_at, updated_at FROM applicants
WHERE identification_number = $1
LIMIT 1
`

func (q *Queries) FindApplicantByIdentification(ctx context.Context, identificationNumber *string) (Applicant, error) {
	row := q.db.QueryRow(ctx, findApplicantByIdentification, identificationNumber)
	var i Applicant
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.FullName,
		&i.Organization,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.IdentificationNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getApplicant = `-- name: GetApplicant :one
SELECT id, type, full_name, organization, email, phone, address, identification_number, created_at, updated_at FROM applicants
WHERE id = $1
`

func (q *Queries) GetApplicant(ctx context.Context, id uuid.UUID) (Applicant, error) {
	row := q.db.QueryRow(ctx, getApplicant, id)
	var i Applicant
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.FullName,
		&i.Organization,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.IdentificationNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getApplicantByEmailOrPhone = `-- name: GetApplicantByEmailOrPhone :one
SELECT id, type, full_name, organization, email, phone, address, identification_number, created_at, updated_at FROM applicants
WHERE email = $1 OR phone = $2
ORDER BY created_at DESC
LIMIT 1
`

type GetApplicantByEmailOrPhoneParams struct {
	Email *string `json:"email"`
	Phone *string `json:"phone"`
}

func (q *Queries) GetApplicantByEmailOrPhone(ctx context.Context, arg GetApplicantByEmailOrPhoneParams) (Applicant, error) {
	row := q.db.QueryRow(ctx, getApplicantByEmailOrPhone, arg.Email, arg.Phone)
	var i Applicant
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.FullName,
		&i.Organization,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.IdentificationNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listApplicants = `-- name: ListApplicants :many
SELECT id, type, full_name, organization, email, phone, address, identification_number, created_at, updated_at FROM applicants
WHERE
    ($1::VARCHAR IS NULL OR type = $1)
    AND ($2::TEXT IS NULL OR 
         full_name ILIKE '%' || $2 || '%' OR
         organization ILIKE '%' || $2 || '%')
ORDER BY created_at DESC
LIMIT $4
OFFSET $3
`

type ListApplicantsParams struct {
	Type   *string `json:"type"`
	Search *string `json:"search"`
	Offset int32   `json:"offset"`
	Limit  int32   `json:"limit"`
}

func (q *Queries) ListApplicants(ctx context.Context, arg ListApplicantsParams) ([]Applicant, error) {
	rows, err := q.db.Query(ctx, listApplicants,
		arg.Type,
		arg.Search,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Applicant
	for rows.Next() {
		var i Applicant
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.FullName,
			&i.Organization,
			&i.Email,
			&i.Phone,
			&i.Address,
			&i.IdentificationNumber,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateApplicant = `-- name: UpdateApplicant :one
UPDATE applicants
SET
    type = COALESCE($2, type),
    full_name = COALESCE($3, full_name),
    organization = COALESCE($4, organization),
    email = COALESCE($5, email),
    phone = COALESCE($6, phone),
    address = COALESCE($7, address),
    identification_number = COALESCE($8, identification_number)
WHERE id = $1
RETURNING id, type, full_name, organization, email, phone, address, identification_number, created_at, updated_at
`

type UpdateApplicantParams struct {
	ID                   uuid.UUID `json:"id"`
	Type                 *string   `json:"type"`
	FullName             *string   `json:"full_name"`
	Organization         *string   `json:"organization"`
	Email                *string   `json:"email"`
	Phone                *string   `json:"phone"`
	Address              *string   `json:"address"`
	IdentificationNumber *string   `json:"identification_number"`
}

func (q *Queries) UpdateApplicant(ctx context.Context, arg UpdateApplicantParams) (Applicant, error) {
	row := q.db.QueryRow(ctx, updateApplicant,
		arg.ID,
		arg.Type,
		arg.FullName,
		arg.Organization,
		arg.Email,
		arg.Phone,
		arg.Address,
		arg.IdentificationNumber,
	)
	var i Applicant
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.FullName,
		&i.Organization,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.IdentificationNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
