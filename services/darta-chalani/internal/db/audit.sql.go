// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: audit.sql

package db

import (
	"context"
	"encoding/json"

	"github.com/jackc/pgx/v5/pgtype"
)

const countAuditEntries = `-- name: CountAuditEntries :one
SELECT COUNT(*) FROM audit_trail
WHERE entity_type = $1 AND entity_id = $2
`

type CountAuditEntriesParams struct {
	EntityType string      `json:"entity_type"`
	EntityID   pgtype.UUID `json:"entity_id"`
}

func (q *Queries) CountAuditEntries(ctx context.Context, arg CountAuditEntriesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAuditEntries, arg.EntityType, arg.EntityID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAuditEntry = `-- name: CreateAuditEntry :one

INSERT INTO audit_trail (
    entity_type,
    entity_id,
    action,
    performed_by,
    changes,
    ip_address,
    user_agent,
    notes,
    tenant_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, entity_type, entity_id, action, performed_by, performed_at, changes, ip_address, user_agent, notes, tenant_id
`

type CreateAuditEntryParams struct {
	EntityType  string          `json:"entity_type"`
	EntityID    pgtype.UUID     `json:"entity_id"`
	Action      string          `json:"action"`
	PerformedBy string          `json:"performed_by"`
	Changes     json.RawMessage `json:"changes"`
	IpAddress   *string         `json:"ip_address"`
	UserAgent   *string         `json:"user_agent"`
	Notes       *string         `json:"notes"`
	TenantID    string          `json:"tenant_id"`
}

// ============================================================================
// AUDIT TRAIL
// ============================================================================
func (q *Queries) CreateAuditEntry(ctx context.Context, arg CreateAuditEntryParams) (AuditTrail, error) {
	row := q.db.QueryRow(ctx, createAuditEntry,
		arg.EntityType,
		arg.EntityID,
		arg.Action,
		arg.PerformedBy,
		arg.Changes,
		arg.IpAddress,
		arg.UserAgent,
		arg.Notes,
		arg.TenantID,
	)
	var i AuditTrail
	err := row.Scan(
		&i.ID,
		&i.EntityType,
		&i.EntityID,
		&i.Action,
		&i.PerformedBy,
		&i.PerformedAt,
		&i.Changes,
		&i.IpAddress,
		&i.UserAgent,
		&i.Notes,
		&i.TenantID,
	)
	return i, err
}

const getAuditTrail = `-- name: GetAuditTrail :many
SELECT id, entity_type, entity_id, action, performed_by, performed_at, changes, ip_address, user_agent, notes, tenant_id FROM audit_trail
WHERE entity_type = $1 AND entity_id = $2
ORDER BY performed_at DESC
LIMIT $3 OFFSET $4
`

type GetAuditTrailParams struct {
	EntityType string      `json:"entity_type"`
	EntityID   pgtype.UUID `json:"entity_id"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

func (q *Queries) GetAuditTrail(ctx context.Context, arg GetAuditTrailParams) ([]AuditTrail, error) {
	rows, err := q.db.Query(ctx, getAuditTrail,
		arg.EntityType,
		arg.EntityID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuditTrail
	for rows.Next() {
		var i AuditTrail
		if err := rows.Scan(
			&i.ID,
			&i.EntityType,
			&i.EntityID,
			&i.Action,
			&i.PerformedBy,
			&i.PerformedAt,
			&i.Changes,
			&i.IpAddress,
			&i.UserAgent,
			&i.Notes,
			&i.TenantID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuditTrailByEntity = `-- name: GetAuditTrailByEntity :many
SELECT id, entity_type, entity_id, action, performed_by, performed_at, changes, ip_address, user_agent, notes, tenant_id FROM audit_trail
WHERE entity_type = $1 
  AND tenant_id = $2
  AND ($5::TIMESTAMPTZ IS NULL OR performed_at >= $5)
  AND ($6::TIMESTAMPTZ IS NULL OR performed_at <= $6)
ORDER BY performed_at DESC
LIMIT $3 OFFSET $4
`

type GetAuditTrailByEntityParams struct {
	EntityType string             `json:"entity_type"`
	TenantID   string             `json:"tenant_id"`
	Limit      int32              `json:"limit"`
	Offset     int32              `json:"offset"`
	FromDate   pgtype.Timestamptz `json:"from_date"`
	ToDate     pgtype.Timestamptz `json:"to_date"`
}

func (q *Queries) GetAuditTrailByEntity(ctx context.Context, arg GetAuditTrailByEntityParams) ([]AuditTrail, error) {
	rows, err := q.db.Query(ctx, getAuditTrailByEntity,
		arg.EntityType,
		arg.TenantID,
		arg.Limit,
		arg.Offset,
		arg.FromDate,
		arg.ToDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuditTrail
	for rows.Next() {
		var i AuditTrail
		if err := rows.Scan(
			&i.ID,
			&i.EntityType,
			&i.EntityID,
			&i.Action,
			&i.PerformedBy,
			&i.PerformedAt,
			&i.Changes,
			&i.IpAddress,
			&i.UserAgent,
			&i.Notes,
			&i.TenantID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuditTrailByUser = `-- name: GetAuditTrailByUser :many
SELECT id, entity_type, entity_id, action, performed_by, performed_at, changes, ip_address, user_agent, notes, tenant_id FROM audit_trail
WHERE performed_by = $1 AND tenant_id = $2
ORDER BY performed_at DESC
LIMIT $3 OFFSET $4
`

type GetAuditTrailByUserParams struct {
	PerformedBy string `json:"performed_by"`
	TenantID    string `json:"tenant_id"`
	Limit       int32  `json:"limit"`
	Offset      int32  `json:"offset"`
}

func (q *Queries) GetAuditTrailByUser(ctx context.Context, arg GetAuditTrailByUserParams) ([]AuditTrail, error) {
	rows, err := q.db.Query(ctx, getAuditTrailByUser,
		arg.PerformedBy,
		arg.TenantID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuditTrail
	for rows.Next() {
		var i AuditTrail
		if err := rows.Scan(
			&i.ID,
			&i.EntityType,
			&i.EntityID,
			&i.Action,
			&i.PerformedBy,
			&i.PerformedAt,
			&i.Changes,
			&i.IpAddress,
			&i.UserAgent,
			&i.Notes,
			&i.TenantID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
