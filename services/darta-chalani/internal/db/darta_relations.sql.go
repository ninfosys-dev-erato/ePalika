// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: darta_relations.sql

package db

import (
	"context"
	"encoding/json"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addDartaAnnex = `-- name: AddDartaAnnex :exec

INSERT INTO darta_annexes (darta_id, attachment_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type AddDartaAnnexParams struct {
	DartaID      pgtype.UUID `json:"darta_id"`
	AttachmentID pgtype.UUID `json:"attachment_id"`
}

// ============================================================================
// DARTA ANNEXES - Additional attachments
// ============================================================================
func (q *Queries) AddDartaAnnex(ctx context.Context, arg AddDartaAnnexParams) error {
	_, err := q.db.Exec(ctx, addDartaAnnex, arg.DartaID, arg.AttachmentID)
	return err
}

const addDartaRelationship = `-- name: AddDartaRelationship :exec

INSERT INTO darta_relationships (darta_id, related_darta_id, relationship_type)
VALUES ($1, $2, $3)
ON CONFLICT DO NOTHING
`

type AddDartaRelationshipParams struct {
	DartaID          pgtype.UUID `json:"darta_id"`
	RelatedDartaID   pgtype.UUID `json:"related_darta_id"`
	RelationshipType string      `json:"relationship_type"`
}

// ============================================================================
// DARTA RELATIONSHIPS - Related dartas
// ============================================================================
func (q *Queries) AddDartaRelationship(ctx context.Context, arg AddDartaRelationshipParams) error {
	_, err := q.db.Exec(ctx, addDartaRelationship, arg.DartaID, arg.RelatedDartaID, arg.RelationshipType)
	return err
}

const getDartaAnnexes = `-- name: GetDartaAnnexes :many
SELECT a.id, a.filename, a.original_filename, a.mime_type, a.size_bytes, a.storage_path, a.checksum, a.uploaded_by, a.uploaded_at, a.metadata, a.tenant_id, a.created_at
FROM attachments a
JOIN darta_annexes da ON a.id = da.attachment_id
WHERE da.darta_id = $1
ORDER BY da.added_at ASC
`

func (q *Queries) GetDartaAnnexes(ctx context.Context, dartaID pgtype.UUID) ([]Attachment, error) {
	rows, err := q.db.Query(ctx, getDartaAnnexes, dartaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Attachment
	for rows.Next() {
		var i Attachment
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.OriginalFilename,
			&i.MimeType,
			&i.SizeBytes,
			&i.StoragePath,
			&i.Checksum,
			&i.UploadedBy,
			&i.UploadedAt,
			&i.Metadata,
			&i.TenantID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRelatedDartas = `-- name: GetRelatedDartas :many
SELECT d.id, d.darta_number, d.formatted_darta_number, d.fiscal_year_id, d.scope, d.ward_id, d.subject, d.applicant_id, d.intake_channel, d.received_date, d.entry_date, d.is_backdated, d.backdate_reason, d.backdate_approver_id, d.primary_document_id, d.status, d.priority, d.classification_code, d.assigned_to_unit_id, d.current_assignee_id, d.sla_deadline, d.is_overdue, d.created_by, d.created_at, d.updated_at, d.tenant_id, d.idempotency_key, d.metadata, a.id, a.type, a.full_name, a.organization, a.email, a.phone, a.address, a.identification_number, a.created_at, a.updated_at
FROM dartas d
JOIN darta_relationships dr ON d.id = dr.related_darta_id
JOIN applicants a ON d.applicant_id = a.id
WHERE dr.darta_id = $1
ORDER BY dr.created_at DESC
`

type GetRelatedDartasRow struct {
	ID                   uuid.UUID          `json:"id"`
	DartaNumber          *int32             `json:"darta_number"`
	FormattedDartaNumber *string            `json:"formatted_darta_number"`
	FiscalYearID         string             `json:"fiscal_year_id"`
	Scope                string             `json:"scope"`
	WardID               *string            `json:"ward_id"`
	Subject              string             `json:"subject"`
	ApplicantID          uuid.UUID          `json:"applicant_id"`
	IntakeChannel        string             `json:"intake_channel"`
	ReceivedDate         pgtype.Timestamptz `json:"received_date"`
	EntryDate            pgtype.Timestamptz `json:"entry_date"`
	IsBackdated          bool               `json:"is_backdated"`
	BackdateReason       *string            `json:"backdate_reason"`
	BackdateApproverID   *string            `json:"backdate_approver_id"`
	PrimaryDocumentID    uuid.UUID          `json:"primary_document_id"`
	Status               string             `json:"status"`
	Priority             string             `json:"priority"`
	ClassificationCode   *string            `json:"classification_code"`
	AssignedToUnitID     *string            `json:"assigned_to_unit_id"`
	CurrentAssigneeID    *string            `json:"current_assignee_id"`
	SlaDeadline          pgtype.Timestamptz `json:"sla_deadline"`
	IsOverdue            *bool              `json:"is_overdue"`
	CreatedBy            string             `json:"created_by"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	TenantID             string             `json:"tenant_id"`
	IdempotencyKey       *string            `json:"idempotency_key"`
	Metadata             json.RawMessage    `json:"metadata"`
	ID_2                 uuid.UUID          `json:"id_2"`
	Type                 string             `json:"type"`
	FullName             string             `json:"full_name"`
	Organization         *string            `json:"organization"`
	Email                *string            `json:"email"`
	Phone                *string            `json:"phone"`
	Address              *string            `json:"address"`
	IdentificationNumber *string            `json:"identification_number"`
	CreatedAt_2          pgtype.Timestamptz `json:"created_at_2"`
	UpdatedAt_2          pgtype.Timestamptz `json:"updated_at_2"`
}

func (q *Queries) GetRelatedDartas(ctx context.Context, dartaID pgtype.UUID) ([]GetRelatedDartasRow, error) {
	rows, err := q.db.Query(ctx, getRelatedDartas, dartaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRelatedDartasRow
	for rows.Next() {
		var i GetRelatedDartasRow
		if err := rows.Scan(
			&i.ID,
			&i.DartaNumber,
			&i.FormattedDartaNumber,
			&i.FiscalYearID,
			&i.Scope,
			&i.WardID,
			&i.Subject,
			&i.ApplicantID,
			&i.IntakeChannel,
			&i.ReceivedDate,
			&i.EntryDate,
			&i.IsBackdated,
			&i.BackdateReason,
			&i.BackdateApproverID,
			&i.PrimaryDocumentID,
			&i.Status,
			&i.Priority,
			&i.ClassificationCode,
			&i.AssignedToUnitID,
			&i.CurrentAssigneeID,
			&i.SlaDeadline,
			&i.IsOverdue,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TenantID,
			&i.IdempotencyKey,
			&i.Metadata,
			&i.ID_2,
			&i.Type,
			&i.FullName,
			&i.Organization,
			&i.Email,
			&i.Phone,
			&i.Address,
			&i.IdentificationNumber,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeAllDartaAnnexes = `-- name: RemoveAllDartaAnnexes :exec
DELETE FROM darta_annexes WHERE darta_id = $1
`

func (q *Queries) RemoveAllDartaAnnexes(ctx context.Context, dartaID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, removeAllDartaAnnexes, dartaID)
	return err
}

const removeAllDartaRelationships = `-- name: RemoveAllDartaRelationships :exec
DELETE FROM darta_relationships WHERE darta_id = $1
`

func (q *Queries) RemoveAllDartaRelationships(ctx context.Context, dartaID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, removeAllDartaRelationships, dartaID)
	return err
}

const removeDartaAnnex = `-- name: RemoveDartaAnnex :exec
DELETE FROM darta_annexes
WHERE darta_id = $1 AND attachment_id = $2
`

type RemoveDartaAnnexParams struct {
	DartaID      pgtype.UUID `json:"darta_id"`
	AttachmentID pgtype.UUID `json:"attachment_id"`
}

func (q *Queries) RemoveDartaAnnex(ctx context.Context, arg RemoveDartaAnnexParams) error {
	_, err := q.db.Exec(ctx, removeDartaAnnex, arg.DartaID, arg.AttachmentID)
	return err
}

const removeDartaRelationship = `-- name: RemoveDartaRelationship :exec
DELETE FROM darta_relationships
WHERE darta_id = $1 AND related_darta_id = $2
`

type RemoveDartaRelationshipParams struct {
	DartaID        pgtype.UUID `json:"darta_id"`
	RelatedDartaID pgtype.UUID `json:"related_darta_id"`
}

func (q *Queries) RemoveDartaRelationship(ctx context.Context, arg RemoveDartaRelationshipParams) error {
	_, err := q.db.Exec(ctx, removeDartaRelationship, arg.DartaID, arg.RelatedDartaID)
	return err
}
