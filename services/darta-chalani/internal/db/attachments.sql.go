// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: attachments.sql

package db

import (
	"context"
	"encoding/json"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countAttachments = `-- name: CountAttachments :one
SELECT COUNT(*) FROM attachments
WHERE tenant_id = $1
`

func (q *Queries) CountAttachments(ctx context.Context, tenantID string) (int64, error) {
	row := q.db.QueryRow(ctx, countAttachments, tenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAttachment = `-- name: CreateAttachment :one

INSERT INTO attachments (
    filename,
    original_filename,
    mime_type,
    size_bytes,
    storage_path,
    checksum,
    uploaded_by,
    metadata,
    tenant_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, filename, original_filename, mime_type, size_bytes, storage_path, checksum, uploaded_by, uploaded_at, metadata, tenant_id, created_at
`

type CreateAttachmentParams struct {
	Filename         string          `json:"filename"`
	OriginalFilename string          `json:"original_filename"`
	MimeType         string          `json:"mime_type"`
	SizeBytes        int64           `json:"size_bytes"`
	StoragePath      string          `json:"storage_path"`
	Checksum         string          `json:"checksum"`
	UploadedBy       string          `json:"uploaded_by"`
	Metadata         json.RawMessage `json:"metadata"`
	TenantID         string          `json:"tenant_id"`
}

// ============================================================================
// ATTACHMENTS - File attachments
// ============================================================================
func (q *Queries) CreateAttachment(ctx context.Context, arg CreateAttachmentParams) (Attachment, error) {
	row := q.db.QueryRow(ctx, createAttachment,
		arg.Filename,
		arg.OriginalFilename,
		arg.MimeType,
		arg.SizeBytes,
		arg.StoragePath,
		arg.Checksum,
		arg.UploadedBy,
		arg.Metadata,
		arg.TenantID,
	)
	var i Attachment
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.OriginalFilename,
		&i.MimeType,
		&i.SizeBytes,
		&i.StoragePath,
		&i.Checksum,
		&i.UploadedBy,
		&i.UploadedAt,
		&i.Metadata,
		&i.TenantID,
		&i.CreatedAt,
	)
	return i, err
}

const deleteAttachment = `-- name: DeleteAttachment :exec
DELETE FROM attachments WHERE id = $1
`

func (q *Queries) DeleteAttachment(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAttachment, id)
	return err
}

const getAttachment = `-- name: GetAttachment :one
SELECT id, filename, original_filename, mime_type, size_bytes, storage_path, checksum, uploaded_by, uploaded_at, metadata, tenant_id, created_at FROM attachments
WHERE id = $1
`

func (q *Queries) GetAttachment(ctx context.Context, id uuid.UUID) (Attachment, error) {
	row := q.db.QueryRow(ctx, getAttachment, id)
	var i Attachment
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.OriginalFilename,
		&i.MimeType,
		&i.SizeBytes,
		&i.StoragePath,
		&i.Checksum,
		&i.UploadedBy,
		&i.UploadedAt,
		&i.Metadata,
		&i.TenantID,
		&i.CreatedAt,
	)
	return i, err
}

const getAttachmentByChecksum = `-- name: GetAttachmentByChecksum :one
SELECT id, filename, original_filename, mime_type, size_bytes, storage_path, checksum, uploaded_by, uploaded_at, metadata, tenant_id, created_at FROM attachments
WHERE checksum = $1 AND tenant_id = $2
ORDER BY created_at DESC
LIMIT 1
`

type GetAttachmentByChecksumParams struct {
	Checksum string `json:"checksum"`
	TenantID string `json:"tenant_id"`
}

func (q *Queries) GetAttachmentByChecksum(ctx context.Context, arg GetAttachmentByChecksumParams) (Attachment, error) {
	row := q.db.QueryRow(ctx, getAttachmentByChecksum, arg.Checksum, arg.TenantID)
	var i Attachment
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.OriginalFilename,
		&i.MimeType,
		&i.SizeBytes,
		&i.StoragePath,
		&i.Checksum,
		&i.UploadedBy,
		&i.UploadedAt,
		&i.Metadata,
		&i.TenantID,
		&i.CreatedAt,
	)
	return i, err
}

const getAttachmentsByIDs = `-- name: GetAttachmentsByIDs :many
SELECT id, filename, original_filename, mime_type, size_bytes, storage_path, checksum, uploaded_by, uploaded_at, metadata, tenant_id, created_at FROM attachments
WHERE id = ANY($1::uuid[])
`

func (q *Queries) GetAttachmentsByIDs(ctx context.Context, dollar_1 []pgtype.UUID) ([]Attachment, error) {
	rows, err := q.db.Query(ctx, getAttachmentsByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Attachment
	for rows.Next() {
		var i Attachment
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.OriginalFilename,
			&i.MimeType,
			&i.SizeBytes,
			&i.StoragePath,
			&i.Checksum,
			&i.UploadedBy,
			&i.UploadedAt,
			&i.Metadata,
			&i.TenantID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAttachments = `-- name: ListAttachments :many
SELECT id, filename, original_filename, mime_type, size_bytes, storage_path, checksum, uploaded_by, uploaded_at, metadata, tenant_id, created_at FROM attachments
WHERE tenant_id = $1
ORDER BY uploaded_at DESC
LIMIT $2 OFFSET $3
`

type ListAttachmentsParams struct {
	TenantID string `json:"tenant_id"`
	Limit    int32  `json:"limit"`
	Offset   int32  `json:"offset"`
}

func (q *Queries) ListAttachments(ctx context.Context, arg ListAttachmentsParams) ([]Attachment, error) {
	rows, err := q.db.Query(ctx, listAttachments, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Attachment
	for rows.Next() {
		var i Attachment
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.OriginalFilename,
			&i.MimeType,
			&i.SizeBytes,
			&i.StoragePath,
			&i.Checksum,
			&i.UploadedBy,
			&i.UploadedAt,
			&i.Metadata,
			&i.TenantID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAttachmentsByUploader = `-- name: ListAttachmentsByUploader :many
SELECT id, filename, original_filename, mime_type, size_bytes, storage_path, checksum, uploaded_by, uploaded_at, metadata, tenant_id, created_at FROM attachments
WHERE uploaded_by = $1 AND tenant_id = $2
ORDER BY uploaded_at DESC
LIMIT $3 OFFSET $4
`

type ListAttachmentsByUploaderParams struct {
	UploadedBy string `json:"uploaded_by"`
	TenantID   string `json:"tenant_id"`
	Limit      int32  `json:"limit"`
	Offset     int32  `json:"offset"`
}

func (q *Queries) ListAttachmentsByUploader(ctx context.Context, arg ListAttachmentsByUploaderParams) ([]Attachment, error) {
	rows, err := q.db.Query(ctx, listAttachmentsByUploader,
		arg.UploadedBy,
		arg.TenantID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Attachment
	for rows.Next() {
		var i Attachment
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.OriginalFilename,
			&i.MimeType,
			&i.SizeBytes,
			&i.StoragePath,
			&i.Checksum,
			&i.UploadedBy,
			&i.UploadedAt,
			&i.Metadata,
			&i.TenantID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
