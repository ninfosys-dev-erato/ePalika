// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: chalani_relations.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addChalaniAttachment = `-- name: AddChalaniAttachment :exec

INSERT INTO chalani_attachments (chalani_id, attachment_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type AddChalaniAttachmentParams struct {
	ChalaniID    pgtype.UUID `json:"chalani_id"`
	AttachmentID pgtype.UUID `json:"attachment_id"`
}

// ============================================================================
// CHALANI ATTACHMENTS
// ============================================================================
func (q *Queries) AddChalaniAttachment(ctx context.Context, arg AddChalaniAttachmentParams) error {
	_, err := q.db.Exec(ctx, addChalaniAttachment, arg.ChalaniID, arg.AttachmentID)
	return err
}

const addChalaniSignatory = `-- name: AddChalaniSignatory :one

INSERT INTO chalani_signatories (
    chalani_id,
    user_id,
    role_id,
    order_num,
    is_required
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, chalani_id, user_id, role_id, order_num, is_required, created_at
`

type AddChalaniSignatoryParams struct {
	ChalaniID  pgtype.UUID `json:"chalani_id"`
	UserID     string      `json:"user_id"`
	RoleID     string      `json:"role_id"`
	OrderNum   int32       `json:"order_num"`
	IsRequired bool        `json:"is_required"`
}

// ============================================================================
// CHALANI SIGNATORIES
// ============================================================================
func (q *Queries) AddChalaniSignatory(ctx context.Context, arg AddChalaniSignatoryParams) (ChalaniSignatory, error) {
	row := q.db.QueryRow(ctx, addChalaniSignatory,
		arg.ChalaniID,
		arg.UserID,
		arg.RoleID,
		arg.OrderNum,
		arg.IsRequired,
	)
	var i ChalaniSignatory
	err := row.Scan(
		&i.ID,
		&i.ChalaniID,
		&i.UserID,
		&i.RoleID,
		&i.OrderNum,
		&i.IsRequired,
		&i.CreatedAt,
	)
	return i, err
}

const checkAllSignatoriesApproved = `-- name: CheckAllSignatoriesApproved :one
SELECT 
    COUNT(*) FILTER (WHERE cs.is_required = true) as required_count,
    COUNT(*) FILTER (WHERE cs.is_required = true AND ca.decision = 'APPROVED') as approved_count
FROM chalani_signatories cs
LEFT JOIN chalani_approvals ca ON cs.id = ca.signatory_id
WHERE cs.chalani_id = $1
`

type CheckAllSignatoriesApprovedRow struct {
	RequiredCount int64 `json:"required_count"`
	ApprovedCount int64 `json:"approved_count"`
}

func (q *Queries) CheckAllSignatoriesApproved(ctx context.Context, chalaniID pgtype.UUID) (CheckAllSignatoriesApprovedRow, error) {
	row := q.db.QueryRow(ctx, checkAllSignatoriesApproved, chalaniID)
	var i CheckAllSignatoriesApprovedRow
	err := row.Scan(&i.RequiredCount, &i.ApprovedCount)
	return i, err
}

const countChalaniTemplates = `-- name: CountChalaniTemplates :one
SELECT COUNT(*) FROM chalani_templates
WHERE
    ($1::VARCHAR IS NULL OR category = $1)
    AND ($2::BOOLEAN IS NULL OR is_active = $2)
`

type CountChalaniTemplatesParams struct {
	Category   *string `json:"category"`
	ActiveOnly *bool   `json:"active_only"`
}

func (q *Queries) CountChalaniTemplates(ctx context.Context, arg CountChalaniTemplatesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countChalaniTemplates, arg.Category, arg.ActiveOnly)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createChalaniApproval = `-- name: CreateChalaniApproval :one

INSERT INTO chalani_approvals (
    chalani_id,
    signatory_id,
    decision,
    notes
) VALUES (
    $1, $2, $3, $4
) RETURNING id, chalani_id, signatory_id, decision, notes, approved_at
`

type CreateChalaniApprovalParams struct {
	ChalaniID   pgtype.UUID `json:"chalani_id"`
	SignatoryID pgtype.UUID `json:"signatory_id"`
	Decision    string      `json:"decision"`
	Notes       *string     `json:"notes"`
}

// ============================================================================
// CHALANI APPROVALS
// ============================================================================
func (q *Queries) CreateChalaniApproval(ctx context.Context, arg CreateChalaniApprovalParams) (ChalaniApproval, error) {
	row := q.db.QueryRow(ctx, createChalaniApproval,
		arg.ChalaniID,
		arg.SignatoryID,
		arg.Decision,
		arg.Notes,
	)
	var i ChalaniApproval
	err := row.Scan(
		&i.ID,
		&i.ChalaniID,
		&i.SignatoryID,
		&i.Decision,
		&i.Notes,
		&i.ApprovedAt,
	)
	return i, err
}

const createChalaniTemplate = `-- name: CreateChalaniTemplate :one

INSERT INTO chalani_templates (
    name,
    category,
    subject,
    body,
    required_signatory_role_ids,
    is_active
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, name, category, subject, body, required_signatory_role_ids, is_active, created_at, updated_at
`

type CreateChalaniTemplateParams struct {
	Name                     string   `json:"name"`
	Category                 string   `json:"category"`
	Subject                  string   `json:"subject"`
	Body                     string   `json:"body"`
	RequiredSignatoryRoleIds []string `json:"required_signatory_role_ids"`
	IsActive                 bool     `json:"is_active"`
}

// ============================================================================
// CHALANI TEMPLATES
// ============================================================================
func (q *Queries) CreateChalaniTemplate(ctx context.Context, arg CreateChalaniTemplateParams) (ChalaniTemplate, error) {
	row := q.db.QueryRow(ctx, createChalaniTemplate,
		arg.Name,
		arg.Category,
		arg.Subject,
		arg.Body,
		arg.RequiredSignatoryRoleIds,
		arg.IsActive,
	)
	var i ChalaniTemplate
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Category,
		&i.Subject,
		&i.Body,
		&i.RequiredSignatoryRoleIds,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteChalaniTemplate = `-- name: DeleteChalaniTemplate :exec
DELETE FROM chalani_templates WHERE id = $1
`

func (q *Queries) DeleteChalaniTemplate(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteChalaniTemplate, id)
	return err
}

const getChalaniApproval = `-- name: GetChalaniApproval :one
SELECT id, chalani_id, signatory_id, decision, notes, approved_at FROM chalani_approvals
WHERE id = $1
`

func (q *Queries) GetChalaniApproval(ctx context.Context, id uuid.UUID) (ChalaniApproval, error) {
	row := q.db.QueryRow(ctx, getChalaniApproval, id)
	var i ChalaniApproval
	err := row.Scan(
		&i.ID,
		&i.ChalaniID,
		&i.SignatoryID,
		&i.Decision,
		&i.Notes,
		&i.ApprovedAt,
	)
	return i, err
}

const getChalaniApprovals = `-- name: GetChalaniApprovals :many
SELECT ca.id, ca.chalani_id, ca.signatory_id, ca.decision, ca.notes, ca.approved_at, cs.id, cs.chalani_id, cs.user_id, cs.role_id, cs.order_num, cs.is_required, cs.created_at
FROM chalani_approvals ca
JOIN chalani_signatories cs ON ca.signatory_id = cs.id
WHERE ca.chalani_id = $1
ORDER BY cs.order_num ASC
`

type GetChalaniApprovalsRow struct {
	ID          uuid.UUID          `json:"id"`
	ChalaniID   pgtype.UUID        `json:"chalani_id"`
	SignatoryID pgtype.UUID        `json:"signatory_id"`
	Decision    string             `json:"decision"`
	Notes       *string            `json:"notes"`
	ApprovedAt  pgtype.Timestamptz `json:"approved_at"`
	ID_2        uuid.UUID          `json:"id_2"`
	ChalaniID_2 pgtype.UUID        `json:"chalani_id_2"`
	UserID      string             `json:"user_id"`
	RoleID      string             `json:"role_id"`
	OrderNum    int32              `json:"order_num"`
	IsRequired  bool               `json:"is_required"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetChalaniApprovals(ctx context.Context, chalaniID pgtype.UUID) ([]GetChalaniApprovalsRow, error) {
	rows, err := q.db.Query(ctx, getChalaniApprovals, chalaniID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChalaniApprovalsRow
	for rows.Next() {
		var i GetChalaniApprovalsRow
		if err := rows.Scan(
			&i.ID,
			&i.ChalaniID,
			&i.SignatoryID,
			&i.Decision,
			&i.Notes,
			&i.ApprovedAt,
			&i.ID_2,
			&i.ChalaniID_2,
			&i.UserID,
			&i.RoleID,
			&i.OrderNum,
			&i.IsRequired,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChalaniAttachments = `-- name: GetChalaniAttachments :many
SELECT a.id, a.filename, a.original_filename, a.mime_type, a.size_bytes, a.storage_path, a.checksum, a.uploaded_by, a.uploaded_at, a.metadata, a.tenant_id, a.created_at
FROM attachments a
JOIN chalani_attachments ca ON a.id = ca.attachment_id
WHERE ca.chalani_id = $1
ORDER BY ca.added_at ASC
`

func (q *Queries) GetChalaniAttachments(ctx context.Context, chalaniID pgtype.UUID) ([]Attachment, error) {
	rows, err := q.db.Query(ctx, getChalaniAttachments, chalaniID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Attachment
	for rows.Next() {
		var i Attachment
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.OriginalFilename,
			&i.MimeType,
			&i.SizeBytes,
			&i.StoragePath,
			&i.Checksum,
			&i.UploadedBy,
			&i.UploadedAt,
			&i.Metadata,
			&i.TenantID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChalaniSignatories = `-- name: GetChalaniSignatories :many
SELECT id, chalani_id, user_id, role_id, order_num, is_required, created_at FROM chalani_signatories
WHERE chalani_id = $1
ORDER BY order_num ASC
`

func (q *Queries) GetChalaniSignatories(ctx context.Context, chalaniID pgtype.UUID) ([]ChalaniSignatory, error) {
	rows, err := q.db.Query(ctx, getChalaniSignatories, chalaniID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChalaniSignatory
	for rows.Next() {
		var i ChalaniSignatory
		if err := rows.Scan(
			&i.ID,
			&i.ChalaniID,
			&i.UserID,
			&i.RoleID,
			&i.OrderNum,
			&i.IsRequired,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChalaniSignatory = `-- name: GetChalaniSignatory :one
SELECT id, chalani_id, user_id, role_id, order_num, is_required, created_at FROM chalani_signatories
WHERE id = $1
`

func (q *Queries) GetChalaniSignatory(ctx context.Context, id uuid.UUID) (ChalaniSignatory, error) {
	row := q.db.QueryRow(ctx, getChalaniSignatory, id)
	var i ChalaniSignatory
	err := row.Scan(
		&i.ID,
		&i.ChalaniID,
		&i.UserID,
		&i.RoleID,
		&i.OrderNum,
		&i.IsRequired,
		&i.CreatedAt,
	)
	return i, err
}

const getChalaniTemplate = `-- name: GetChalaniTemplate :one
SELECT id, name, category, subject, body, required_signatory_role_ids, is_active, created_at, updated_at FROM chalani_templates
WHERE id = $1
`

func (q *Queries) GetChalaniTemplate(ctx context.Context, id uuid.UUID) (ChalaniTemplate, error) {
	row := q.db.QueryRow(ctx, getChalaniTemplate, id)
	var i ChalaniTemplate
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Category,
		&i.Subject,
		&i.Body,
		&i.RequiredSignatoryRoleIds,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listChalaniTemplates = `-- name: ListChalaniTemplates :many
SELECT id, name, category, subject, body, required_signatory_role_ids, is_active, created_at, updated_at FROM chalani_templates
WHERE
    ($1::VARCHAR IS NULL OR category = $1)
    AND ($2::BOOLEAN IS NULL OR is_active = $2)
ORDER BY name ASC
LIMIT $4
OFFSET $3
`

type ListChalaniTemplatesParams struct {
	Category   *string `json:"category"`
	ActiveOnly *bool   `json:"active_only"`
	Offset     int32   `json:"offset"`
	Limit      int32   `json:"limit"`
}

func (q *Queries) ListChalaniTemplates(ctx context.Context, arg ListChalaniTemplatesParams) ([]ChalaniTemplate, error) {
	rows, err := q.db.Query(ctx, listChalaniTemplates,
		arg.Category,
		arg.ActiveOnly,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChalaniTemplate
	for rows.Next() {
		var i ChalaniTemplate
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Category,
			&i.Subject,
			&i.Body,
			&i.RequiredSignatoryRoleIds,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeChalaniAttachment = `-- name: RemoveChalaniAttachment :exec
DELETE FROM chalani_attachments
WHERE chalani_id = $1 AND attachment_id = $2
`

type RemoveChalaniAttachmentParams struct {
	ChalaniID    pgtype.UUID `json:"chalani_id"`
	AttachmentID pgtype.UUID `json:"attachment_id"`
}

func (q *Queries) RemoveChalaniAttachment(ctx context.Context, arg RemoveChalaniAttachmentParams) error {
	_, err := q.db.Exec(ctx, removeChalaniAttachment, arg.ChalaniID, arg.AttachmentID)
	return err
}

const removeChalaniSignatory = `-- name: RemoveChalaniSignatory :exec
DELETE FROM chalani_signatories
WHERE id = $1
`

func (q *Queries) RemoveChalaniSignatory(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, removeChalaniSignatory, id)
	return err
}

const updateChalaniTemplate = `-- name: UpdateChalaniTemplate :one
UPDATE chalani_templates
SET
    name = COALESCE($2, name),
    category = COALESCE($3, category),
    subject = COALESCE($4, subject),
    body = COALESCE($5, body),
    required_signatory_role_ids = COALESCE($6::TEXT[], required_signatory_role_ids),
    is_active = COALESCE($7, is_active)
WHERE id = $1
RETURNING id, name, category, subject, body, required_signatory_role_ids, is_active, created_at, updated_at
`

type UpdateChalaniTemplateParams struct {
	ID                       uuid.UUID `json:"id"`
	Name                     *string   `json:"name"`
	Category                 *string   `json:"category"`
	Subject                  *string   `json:"subject"`
	Body                     *string   `json:"body"`
	RequiredSignatoryRoleIds []string  `json:"required_signatory_role_ids"`
	IsActive                 *bool     `json:"is_active"`
}

func (q *Queries) UpdateChalaniTemplate(ctx context.Context, arg UpdateChalaniTemplateParams) (ChalaniTemplate, error) {
	row := q.db.QueryRow(ctx, updateChalaniTemplate,
		arg.ID,
		arg.Name,
		arg.Category,
		arg.Subject,
		arg.Body,
		arg.RequiredSignatoryRoleIds,
		arg.IsActive,
	)
	var i ChalaniTemplate
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Category,
		&i.Subject,
		&i.Body,
		&i.RequiredSignatoryRoleIds,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
