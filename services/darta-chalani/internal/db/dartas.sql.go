// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: dartas.sql

package db

import (
	"context"
	"encoding/json"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const closeDarta = `-- name: CloseDarta :one
UPDATE dartas
SET 
    status = 'CLOSED',
    updated_at = NOW()
WHERE id = $1
RETURNING id, darta_number, formatted_darta_number, fiscal_year_id, scope, ward_id, subject, applicant_id, intake_channel, received_date, entry_date, is_backdated, backdate_reason, backdate_approver_id, primary_document_id, status, priority, classification_code, assigned_to_unit_id, current_assignee_id, sla_deadline, is_overdue, created_by, created_at, updated_at, tenant_id, idempotency_key, metadata
`

func (q *Queries) CloseDarta(ctx context.Context, id uuid.UUID) (Darta, error) {
	row := q.db.QueryRow(ctx, closeDarta, id)
	var i Darta
	err := row.Scan(
		&i.ID,
		&i.DartaNumber,
		&i.FormattedDartaNumber,
		&i.FiscalYearID,
		&i.Scope,
		&i.WardID,
		&i.Subject,
		&i.ApplicantID,
		&i.IntakeChannel,
		&i.ReceivedDate,
		&i.EntryDate,
		&i.IsBackdated,
		&i.BackdateReason,
		&i.BackdateApproverID,
		&i.PrimaryDocumentID,
		&i.Status,
		&i.Priority,
		&i.ClassificationCode,
		&i.AssignedToUnitID,
		&i.CurrentAssigneeID,
		&i.SlaDeadline,
		&i.IsOverdue,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
		&i.IdempotencyKey,
		&i.Metadata,
	)
	return i, err
}

const countDartas = `-- name: CountDartas :one
SELECT COUNT(*)
FROM dartas d
WHERE
    ($1::VARCHAR IS NULL OR d.fiscal_year_id = $1)
    AND ($2::VARCHAR IS NULL OR d.scope = $2)
    AND ($3::VARCHAR IS NULL OR d.ward_id = $3)
    AND ($4::VARCHAR IS NULL OR d.status = $4)
    AND ($5::VARCHAR IS NULL OR d.priority = $5)
    AND ($6::VARCHAR IS NULL OR d.assigned_to_unit_id = $6)
    AND ($7::VARCHAR IS NULL OR d.current_assignee_id = $7)
    AND ($8::BOOLEAN IS NULL OR d.is_overdue = $8)
    AND ($9::TIMESTAMPTZ IS NULL OR d.received_date >= $9)
    AND ($10::TIMESTAMPTZ IS NULL OR d.received_date <= $10)
    AND ($11::TEXT IS NULL OR d.subject ILIKE '%' || $11 || '%')
    AND d.tenant_id = $12
`

type CountDartasParams struct {
	FiscalYearID      *string            `json:"fiscal_year_id"`
	Scope             *string            `json:"scope"`
	WardID            *string            `json:"ward_id"`
	Status            *string            `json:"status"`
	Priority          *string            `json:"priority"`
	AssignedToUnitID  *string            `json:"assigned_to_unit_id"`
	CurrentAssigneeID *string            `json:"current_assignee_id"`
	IsOverdue         *bool              `json:"is_overdue"`
	FromDate          pgtype.Timestamptz `json:"from_date"`
	ToDate            pgtype.Timestamptz `json:"to_date"`
	Search            *string            `json:"search"`
	TenantID          string             `json:"tenant_id"`
}

func (q *Queries) CountDartas(ctx context.Context, arg CountDartasParams) (int64, error) {
	row := q.db.QueryRow(ctx, countDartas,
		arg.FiscalYearID,
		arg.Scope,
		arg.WardID,
		arg.Status,
		arg.Priority,
		arg.AssignedToUnitID,
		arg.CurrentAssigneeID,
		arg.IsOverdue,
		arg.FromDate,
		arg.ToDate,
		arg.Search,
		arg.TenantID,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMyDartas = `-- name: CountMyDartas :one
SELECT COUNT(*)
FROM dartas
WHERE current_assignee_id = $1
  AND ($3::VARCHAR IS NULL OR status = $3)
  AND tenant_id = $2
`

type CountMyDartasParams struct {
	CurrentAssigneeID *string `json:"current_assignee_id"`
	TenantID          string  `json:"tenant_id"`
	Status            *string `json:"status"`
}

func (q *Queries) CountMyDartas(ctx context.Context, arg CountMyDartasParams) (int64, error) {
	row := q.db.QueryRow(ctx, countMyDartas, arg.CurrentAssigneeID, arg.TenantID, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDarta = `-- name: CreateDarta :one

INSERT INTO dartas (
    fiscal_year_id,
    scope,
    ward_id,
    subject,
    applicant_id,
    intake_channel,
    received_date,
    entry_date,
    is_backdated,
    backdate_reason,
    backdate_approver_id,
    primary_document_id,
    status,
    priority,
    created_by,
    tenant_id,
    idempotency_key,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18
) RETURNING id, darta_number, formatted_darta_number, fiscal_year_id, scope, ward_id, subject, applicant_id, intake_channel, received_date, entry_date, is_backdated, backdate_reason, backdate_approver_id, primary_document_id, status, priority, classification_code, assigned_to_unit_id, current_assignee_id, sla_deadline, is_overdue, created_by, created_at, updated_at, tenant_id, idempotency_key, metadata
`

type CreateDartaParams struct {
	FiscalYearID       string             `json:"fiscal_year_id"`
	Scope              string             `json:"scope"`
	WardID             *string            `json:"ward_id"`
	Subject            string             `json:"subject"`
	ApplicantID        uuid.UUID          `json:"applicant_id"`
	IntakeChannel      string             `json:"intake_channel"`
	ReceivedDate       pgtype.Timestamptz `json:"received_date"`
	EntryDate          pgtype.Timestamptz `json:"entry_date"`
	IsBackdated        bool               `json:"is_backdated"`
	BackdateReason     *string            `json:"backdate_reason"`
	BackdateApproverID *string            `json:"backdate_approver_id"`
	PrimaryDocumentID  uuid.UUID          `json:"primary_document_id"`
	Status             string             `json:"status"`
	Priority           string             `json:"priority"`
	CreatedBy          string             `json:"created_by"`
	TenantID           string             `json:"tenant_id"`
	IdempotencyKey     *string            `json:"idempotency_key"`
	Metadata           json.RawMessage    `json:"metadata"`
}

// ============================================================================
// DARTAS - Incoming correspondence (main queries)
// ============================================================================
func (q *Queries) CreateDarta(ctx context.Context, arg CreateDartaParams) (Darta, error) {
	row := q.db.QueryRow(ctx, createDarta,
		arg.FiscalYearID,
		arg.Scope,
		arg.WardID,
		arg.Subject,
		arg.ApplicantID,
		arg.IntakeChannel,
		arg.ReceivedDate,
		arg.EntryDate,
		arg.IsBackdated,
		arg.BackdateReason,
		arg.BackdateApproverID,
		arg.PrimaryDocumentID,
		arg.Status,
		arg.Priority,
		arg.CreatedBy,
		arg.TenantID,
		arg.IdempotencyKey,
		arg.Metadata,
	)
	var i Darta
	err := row.Scan(
		&i.ID,
		&i.DartaNumber,
		&i.FormattedDartaNumber,
		&i.FiscalYearID,
		&i.Scope,
		&i.WardID,
		&i.Subject,
		&i.ApplicantID,
		&i.IntakeChannel,
		&i.ReceivedDate,
		&i.EntryDate,
		&i.IsBackdated,
		&i.BackdateReason,
		&i.BackdateApproverID,
		&i.PrimaryDocumentID,
		&i.Status,
		&i.Priority,
		&i.ClassificationCode,
		&i.AssignedToUnitID,
		&i.CurrentAssigneeID,
		&i.SlaDeadline,
		&i.IsOverdue,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
		&i.IdempotencyKey,
		&i.Metadata,
	)
	return i, err
}

const getDarta = `-- name: GetDarta :one
SELECT d.id, d.darta_number, d.formatted_darta_number, d.fiscal_year_id, d.scope, d.ward_id, d.subject, d.applicant_id, d.intake_channel, d.received_date, d.entry_date, d.is_backdated, d.backdate_reason, d.backdate_approver_id, d.primary_document_id, d.status, d.priority, d.classification_code, d.assigned_to_unit_id, d.current_assignee_id, d.sla_deadline, d.is_overdue, d.created_by, d.created_at, d.updated_at, d.tenant_id, d.idempotency_key, d.metadata, a.id, a.type, a.full_name, a.organization, a.email, a.phone, a.address, a.identification_number, a.created_at, a.updated_at 
FROM dartas d
JOIN applicants a ON d.applicant_id = a.id
WHERE d.id = $1
`

type GetDartaRow struct {
	ID                   uuid.UUID          `json:"id"`
	DartaNumber          *int32             `json:"darta_number"`
	FormattedDartaNumber *string            `json:"formatted_darta_number"`
	FiscalYearID         string             `json:"fiscal_year_id"`
	Scope                string             `json:"scope"`
	WardID               *string            `json:"ward_id"`
	Subject              string             `json:"subject"`
	ApplicantID          uuid.UUID          `json:"applicant_id"`
	IntakeChannel        string             `json:"intake_channel"`
	ReceivedDate         pgtype.Timestamptz `json:"received_date"`
	EntryDate            pgtype.Timestamptz `json:"entry_date"`
	IsBackdated          bool               `json:"is_backdated"`
	BackdateReason       *string            `json:"backdate_reason"`
	BackdateApproverID   *string            `json:"backdate_approver_id"`
	PrimaryDocumentID    uuid.UUID          `json:"primary_document_id"`
	Status               string             `json:"status"`
	Priority             string             `json:"priority"`
	ClassificationCode   *string            `json:"classification_code"`
	AssignedToUnitID     *string            `json:"assigned_to_unit_id"`
	CurrentAssigneeID    *string            `json:"current_assignee_id"`
	SlaDeadline          pgtype.Timestamptz `json:"sla_deadline"`
	IsOverdue            *bool              `json:"is_overdue"`
	CreatedBy            string             `json:"created_by"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	TenantID             string             `json:"tenant_id"`
	IdempotencyKey       *string            `json:"idempotency_key"`
	Metadata             json.RawMessage    `json:"metadata"`
	ID_2                 uuid.UUID          `json:"id_2"`
	Type                 string             `json:"type"`
	FullName             string             `json:"full_name"`
	Organization         *string            `json:"organization"`
	Email                *string            `json:"email"`
	Phone                *string            `json:"phone"`
	Address              *string            `json:"address"`
	IdentificationNumber *string            `json:"identification_number"`
	CreatedAt_2          pgtype.Timestamptz `json:"created_at_2"`
	UpdatedAt_2          pgtype.Timestamptz `json:"updated_at_2"`
}

func (q *Queries) GetDarta(ctx context.Context, id uuid.UUID) (GetDartaRow, error) {
	row := q.db.QueryRow(ctx, getDarta, id)
	var i GetDartaRow
	err := row.Scan(
		&i.ID,
		&i.DartaNumber,
		&i.FormattedDartaNumber,
		&i.FiscalYearID,
		&i.Scope,
		&i.WardID,
		&i.Subject,
		&i.ApplicantID,
		&i.IntakeChannel,
		&i.ReceivedDate,
		&i.EntryDate,
		&i.IsBackdated,
		&i.BackdateReason,
		&i.BackdateApproverID,
		&i.PrimaryDocumentID,
		&i.Status,
		&i.Priority,
		&i.ClassificationCode,
		&i.AssignedToUnitID,
		&i.CurrentAssigneeID,
		&i.SlaDeadline,
		&i.IsOverdue,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
		&i.IdempotencyKey,
		&i.Metadata,
		&i.ID_2,
		&i.Type,
		&i.FullName,
		&i.Organization,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.IdentificationNumber,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
	)
	return i, err
}

const getDartaByIdempotencyKey = `-- name: GetDartaByIdempotencyKey :one
SELECT id, darta_number, formatted_darta_number, fiscal_year_id, scope, ward_id, subject, applicant_id, intake_channel, received_date, entry_date, is_backdated, backdate_reason, backdate_approver_id, primary_document_id, status, priority, classification_code, assigned_to_unit_id, current_assignee_id, sla_deadline, is_overdue, created_by, created_at, updated_at, tenant_id, idempotency_key, metadata FROM dartas
WHERE idempotency_key = $1 AND tenant_id = $2
`

type GetDartaByIdempotencyKeyParams struct {
	IdempotencyKey *string `json:"idempotency_key"`
	TenantID       string  `json:"tenant_id"`
}

func (q *Queries) GetDartaByIdempotencyKey(ctx context.Context, arg GetDartaByIdempotencyKeyParams) (Darta, error) {
	row := q.db.QueryRow(ctx, getDartaByIdempotencyKey, arg.IdempotencyKey, arg.TenantID)
	var i Darta
	err := row.Scan(
		&i.ID,
		&i.DartaNumber,
		&i.FormattedDartaNumber,
		&i.FiscalYearID,
		&i.Scope,
		&i.WardID,
		&i.Subject,
		&i.ApplicantID,
		&i.IntakeChannel,
		&i.ReceivedDate,
		&i.EntryDate,
		&i.IsBackdated,
		&i.BackdateReason,
		&i.BackdateApproverID,
		&i.PrimaryDocumentID,
		&i.Status,
		&i.Priority,
		&i.ClassificationCode,
		&i.AssignedToUnitID,
		&i.CurrentAssigneeID,
		&i.SlaDeadline,
		&i.IsOverdue,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
		&i.IdempotencyKey,
		&i.Metadata,
	)
	return i, err
}

const getDartaByNumber = `-- name: GetDartaByNumber :one
SELECT d.id, d.darta_number, d.formatted_darta_number, d.fiscal_year_id, d.scope, d.ward_id, d.subject, d.applicant_id, d.intake_channel, d.received_date, d.entry_date, d.is_backdated, d.backdate_reason, d.backdate_approver_id, d.primary_document_id, d.status, d.priority, d.classification_code, d.assigned_to_unit_id, d.current_assignee_id, d.sla_deadline, d.is_overdue, d.created_by, d.created_at, d.updated_at, d.tenant_id, d.idempotency_key, d.metadata, a.id, a.type, a.full_name, a.organization, a.email, a.phone, a.address, a.identification_number, a.created_at, a.updated_at
FROM dartas d
JOIN applicants a ON d.applicant_id = a.id
WHERE d.darta_number = $1 
  AND d.fiscal_year_id = $2
  AND d.scope = $3
  AND (d.ward_id = $4 OR (d.ward_id IS NULL AND $4::VARCHAR IS NULL))
`

type GetDartaByNumberParams struct {
	DartaNumber  *int32  `json:"darta_number"`
	FiscalYearID string  `json:"fiscal_year_id"`
	Scope        string  `json:"scope"`
	WardID       *string `json:"ward_id"`
}

type GetDartaByNumberRow struct {
	ID                   uuid.UUID          `json:"id"`
	DartaNumber          *int32             `json:"darta_number"`
	FormattedDartaNumber *string            `json:"formatted_darta_number"`
	FiscalYearID         string             `json:"fiscal_year_id"`
	Scope                string             `json:"scope"`
	WardID               *string            `json:"ward_id"`
	Subject              string             `json:"subject"`
	ApplicantID          uuid.UUID          `json:"applicant_id"`
	IntakeChannel        string             `json:"intake_channel"`
	ReceivedDate         pgtype.Timestamptz `json:"received_date"`
	EntryDate            pgtype.Timestamptz `json:"entry_date"`
	IsBackdated          bool               `json:"is_backdated"`
	BackdateReason       *string            `json:"backdate_reason"`
	BackdateApproverID   *string            `json:"backdate_approver_id"`
	PrimaryDocumentID    uuid.UUID          `json:"primary_document_id"`
	Status               string             `json:"status"`
	Priority             string             `json:"priority"`
	ClassificationCode   *string            `json:"classification_code"`
	AssignedToUnitID     *string            `json:"assigned_to_unit_id"`
	CurrentAssigneeID    *string            `json:"current_assignee_id"`
	SlaDeadline          pgtype.Timestamptz `json:"sla_deadline"`
	IsOverdue            *bool              `json:"is_overdue"`
	CreatedBy            string             `json:"created_by"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	TenantID             string             `json:"tenant_id"`
	IdempotencyKey       *string            `json:"idempotency_key"`
	Metadata             json.RawMessage    `json:"metadata"`
	ID_2                 uuid.UUID          `json:"id_2"`
	Type                 string             `json:"type"`
	FullName             string             `json:"full_name"`
	Organization         *string            `json:"organization"`
	Email                *string            `json:"email"`
	Phone                *string            `json:"phone"`
	Address              *string            `json:"address"`
	IdentificationNumber *string            `json:"identification_number"`
	CreatedAt_2          pgtype.Timestamptz `json:"created_at_2"`
	UpdatedAt_2          pgtype.Timestamptz `json:"updated_at_2"`
}

func (q *Queries) GetDartaByNumber(ctx context.Context, arg GetDartaByNumberParams) (GetDartaByNumberRow, error) {
	row := q.db.QueryRow(ctx, getDartaByNumber,
		arg.DartaNumber,
		arg.FiscalYearID,
		arg.Scope,
		arg.WardID,
	)
	var i GetDartaByNumberRow
	err := row.Scan(
		&i.ID,
		&i.DartaNumber,
		&i.FormattedDartaNumber,
		&i.FiscalYearID,
		&i.Scope,
		&i.WardID,
		&i.Subject,
		&i.ApplicantID,
		&i.IntakeChannel,
		&i.ReceivedDate,
		&i.EntryDate,
		&i.IsBackdated,
		&i.BackdateReason,
		&i.BackdateApproverID,
		&i.PrimaryDocumentID,
		&i.Status,
		&i.Priority,
		&i.ClassificationCode,
		&i.AssignedToUnitID,
		&i.CurrentAssigneeID,
		&i.SlaDeadline,
		&i.IsOverdue,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
		&i.IdempotencyKey,
		&i.Metadata,
		&i.ID_2,
		&i.Type,
		&i.FullName,
		&i.Organization,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.IdentificationNumber,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
	)
	return i, err
}

const getDartaSimple = `-- name: GetDartaSimple :one
SELECT id, darta_number, formatted_darta_number, fiscal_year_id, scope, ward_id, subject, applicant_id, intake_channel, received_date, entry_date, is_backdated, backdate_reason, backdate_approver_id, primary_document_id, status, priority, classification_code, assigned_to_unit_id, current_assignee_id, sla_deadline, is_overdue, created_by, created_at, updated_at, tenant_id, idempotency_key, metadata FROM dartas WHERE id = $1
`

func (q *Queries) GetDartaSimple(ctx context.Context, id uuid.UUID) (Darta, error) {
	row := q.db.QueryRow(ctx, getDartaSimple, id)
	var i Darta
	err := row.Scan(
		&i.ID,
		&i.DartaNumber,
		&i.FormattedDartaNumber,
		&i.FiscalYearID,
		&i.Scope,
		&i.WardID,
		&i.Subject,
		&i.ApplicantID,
		&i.IntakeChannel,
		&i.ReceivedDate,
		&i.EntryDate,
		&i.IsBackdated,
		&i.BackdateReason,
		&i.BackdateApproverID,
		&i.PrimaryDocumentID,
		&i.Status,
		&i.Priority,
		&i.ClassificationCode,
		&i.AssignedToUnitID,
		&i.CurrentAssigneeID,
		&i.SlaDeadline,
		&i.IsOverdue,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
		&i.IdempotencyKey,
		&i.Metadata,
	)
	return i, err
}

const getDartaStatsByChannel = `-- name: GetDartaStatsByChannel :many
SELECT intake_channel, COUNT(*) as count
FROM dartas
WHERE tenant_id = $1
  AND ($2::VARCHAR IS NULL OR fiscal_year_id = $2)
  AND ($3::VARCHAR IS NULL OR scope = $3)
  AND ($4::VARCHAR IS NULL OR ward_id = $4)
GROUP BY intake_channel
`

type GetDartaStatsByChannelParams struct {
	TenantID     string  `json:"tenant_id"`
	FiscalYearID *string `json:"fiscal_year_id"`
	Scope        *string `json:"scope"`
	WardID       *string `json:"ward_id"`
}

type GetDartaStatsByChannelRow struct {
	IntakeChannel string `json:"intake_channel"`
	Count         int64  `json:"count"`
}

func (q *Queries) GetDartaStatsByChannel(ctx context.Context, arg GetDartaStatsByChannelParams) ([]GetDartaStatsByChannelRow, error) {
	rows, err := q.db.Query(ctx, getDartaStatsByChannel,
		arg.TenantID,
		arg.FiscalYearID,
		arg.Scope,
		arg.WardID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDartaStatsByChannelRow
	for rows.Next() {
		var i GetDartaStatsByChannelRow
		if err := rows.Scan(&i.IntakeChannel, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDartaStatsByStatus = `-- name: GetDartaStatsByStatus :many
SELECT status, COUNT(*) as count
FROM dartas
WHERE tenant_id = $1
  AND ($2::VARCHAR IS NULL OR fiscal_year_id = $2)
  AND ($3::VARCHAR IS NULL OR scope = $3)
  AND ($4::VARCHAR IS NULL OR ward_id = $4)
GROUP BY status
`

type GetDartaStatsByStatusParams struct {
	TenantID     string  `json:"tenant_id"`
	FiscalYearID *string `json:"fiscal_year_id"`
	Scope        *string `json:"scope"`
	WardID       *string `json:"ward_id"`
}

type GetDartaStatsByStatusRow struct {
	Status string `json:"status"`
	Count  int64  `json:"count"`
}

// Statistics queries
func (q *Queries) GetDartaStatsByStatus(ctx context.Context, arg GetDartaStatsByStatusParams) ([]GetDartaStatsByStatusRow, error) {
	rows, err := q.db.Query(ctx, getDartaStatsByStatus,
		arg.TenantID,
		arg.FiscalYearID,
		arg.Scope,
		arg.WardID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDartaStatsByStatusRow
	for rows.Next() {
		var i GetDartaStatsByStatusRow
		if err := rows.Scan(&i.Status, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMyDartas = `-- name: GetMyDartas :many
SELECT d.id, d.darta_number, d.formatted_darta_number, d.fiscal_year_id, d.scope, d.ward_id, d.subject, d.applicant_id, d.intake_channel, d.received_date, d.entry_date, d.is_backdated, d.backdate_reason, d.backdate_approver_id, d.primary_document_id, d.status, d.priority, d.classification_code, d.assigned_to_unit_id, d.current_assignee_id, d.sla_deadline, d.is_overdue, d.created_by, d.created_at, d.updated_at, d.tenant_id, d.idempotency_key, d.metadata, a.id, a.type, a.full_name, a.organization, a.email, a.phone, a.address, a.identification_number, a.created_at, a.updated_at
FROM dartas d
JOIN applicants a ON d.applicant_id = a.id
WHERE d.current_assignee_id = $1
  AND ($5::VARCHAR IS NULL OR d.status = $5)
  AND d.tenant_id = $2
ORDER BY 
    CASE WHEN d.is_overdue THEN 0 ELSE 1 END,
    d.priority DESC,
    d.received_date DESC
LIMIT $3 OFFSET $4
`

type GetMyDartasParams struct {
	CurrentAssigneeID *string `json:"current_assignee_id"`
	TenantID          string  `json:"tenant_id"`
	Limit             int32   `json:"limit"`
	Offset            int32   `json:"offset"`
	Status            *string `json:"status"`
}

type GetMyDartasRow struct {
	ID                   uuid.UUID          `json:"id"`
	DartaNumber          *int32             `json:"darta_number"`
	FormattedDartaNumber *string            `json:"formatted_darta_number"`
	FiscalYearID         string             `json:"fiscal_year_id"`
	Scope                string             `json:"scope"`
	WardID               *string            `json:"ward_id"`
	Subject              string             `json:"subject"`
	ApplicantID          uuid.UUID          `json:"applicant_id"`
	IntakeChannel        string             `json:"intake_channel"`
	ReceivedDate         pgtype.Timestamptz `json:"received_date"`
	EntryDate            pgtype.Timestamptz `json:"entry_date"`
	IsBackdated          bool               `json:"is_backdated"`
	BackdateReason       *string            `json:"backdate_reason"`
	BackdateApproverID   *string            `json:"backdate_approver_id"`
	PrimaryDocumentID    uuid.UUID          `json:"primary_document_id"`
	Status               string             `json:"status"`
	Priority             string             `json:"priority"`
	ClassificationCode   *string            `json:"classification_code"`
	AssignedToUnitID     *string            `json:"assigned_to_unit_id"`
	CurrentAssigneeID    *string            `json:"current_assignee_id"`
	SlaDeadline          pgtype.Timestamptz `json:"sla_deadline"`
	IsOverdue            *bool              `json:"is_overdue"`
	CreatedBy            string             `json:"created_by"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	TenantID             string             `json:"tenant_id"`
	IdempotencyKey       *string            `json:"idempotency_key"`
	Metadata             json.RawMessage    `json:"metadata"`
	ID_2                 uuid.UUID          `json:"id_2"`
	Type                 string             `json:"type"`
	FullName             string             `json:"full_name"`
	Organization         *string            `json:"organization"`
	Email                *string            `json:"email"`
	Phone                *string            `json:"phone"`
	Address              *string            `json:"address"`
	IdentificationNumber *string            `json:"identification_number"`
	CreatedAt_2          pgtype.Timestamptz `json:"created_at_2"`
	UpdatedAt_2          pgtype.Timestamptz `json:"updated_at_2"`
}

func (q *Queries) GetMyDartas(ctx context.Context, arg GetMyDartasParams) ([]GetMyDartasRow, error) {
	rows, err := q.db.Query(ctx, getMyDartas,
		arg.CurrentAssigneeID,
		arg.TenantID,
		arg.Limit,
		arg.Offset,
		arg.Status,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMyDartasRow
	for rows.Next() {
		var i GetMyDartasRow
		if err := rows.Scan(
			&i.ID,
			&i.DartaNumber,
			&i.FormattedDartaNumber,
			&i.FiscalYearID,
			&i.Scope,
			&i.WardID,
			&i.Subject,
			&i.ApplicantID,
			&i.IntakeChannel,
			&i.ReceivedDate,
			&i.EntryDate,
			&i.IsBackdated,
			&i.BackdateReason,
			&i.BackdateApproverID,
			&i.PrimaryDocumentID,
			&i.Status,
			&i.Priority,
			&i.ClassificationCode,
			&i.AssignedToUnitID,
			&i.CurrentAssigneeID,
			&i.SlaDeadline,
			&i.IsOverdue,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TenantID,
			&i.IdempotencyKey,
			&i.Metadata,
			&i.ID_2,
			&i.Type,
			&i.FullName,
			&i.Organization,
			&i.Email,
			&i.Phone,
			&i.Address,
			&i.IdentificationNumber,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNextDartaNumber = `-- name: GetNextDartaNumber :one
SELECT COALESCE(MAX(darta_number), 0) + 1 as next_number
FROM dartas
WHERE fiscal_year_id = $1
  AND scope = $2
  AND (ward_id = $4 OR (ward_id IS NULL AND $4::VARCHAR IS NULL))
  AND tenant_id = $3
`

type GetNextDartaNumberParams struct {
	FiscalYearID string  `json:"fiscal_year_id"`
	Scope        string  `json:"scope"`
	TenantID     string  `json:"tenant_id"`
	WardID       *string `json:"ward_id"`
}

func (q *Queries) GetNextDartaNumber(ctx context.Context, arg GetNextDartaNumberParams) (int32, error) {
	row := q.db.QueryRow(ctx, getNextDartaNumber,
		arg.FiscalYearID,
		arg.Scope,
		arg.TenantID,
		arg.WardID,
	)
	var next_number int32
	err := row.Scan(&next_number)
	return next_number, err
}

const getOverdueCount = `-- name: GetOverdueCount :one
SELECT COUNT(*)
FROM dartas
WHERE is_overdue = true
  AND tenant_id = $1
  AND ($2::VARCHAR IS NULL OR fiscal_year_id = $2)
  AND ($3::VARCHAR IS NULL OR scope = $3)
  AND ($4::VARCHAR IS NULL OR ward_id = $4)
`

type GetOverdueCountParams struct {
	TenantID     string  `json:"tenant_id"`
	FiscalYearID *string `json:"fiscal_year_id"`
	Scope        *string `json:"scope"`
	WardID       *string `json:"ward_id"`
}

func (q *Queries) GetOverdueCount(ctx context.Context, arg GetOverdueCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getOverdueCount,
		arg.TenantID,
		arg.FiscalYearID,
		arg.Scope,
		arg.WardID,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const listDartas = `-- name: ListDartas :many
SELECT d.id, d.darta_number, d.formatted_darta_number, d.fiscal_year_id, d.scope, d.ward_id, d.subject, d.applicant_id, d.intake_channel, d.received_date, d.entry_date, d.is_backdated, d.backdate_reason, d.backdate_approver_id, d.primary_document_id, d.status, d.priority, d.classification_code, d.assigned_to_unit_id, d.current_assignee_id, d.sla_deadline, d.is_overdue, d.created_by, d.created_at, d.updated_at, d.tenant_id, d.idempotency_key, d.metadata, a.id, a.type, a.full_name, a.organization, a.email, a.phone, a.address, a.identification_number, a.created_at, a.updated_at
FROM dartas d
JOIN applicants a ON d.applicant_id = a.id
WHERE
    ($1::VARCHAR IS NULL OR d.fiscal_year_id = $1)
    AND ($2::VARCHAR IS NULL OR d.scope = $2)
    AND ($3::VARCHAR IS NULL OR d.ward_id = $3)
    AND ($4::VARCHAR IS NULL OR d.status = $4)
    AND ($5::VARCHAR IS NULL OR d.priority = $5)
    AND ($6::VARCHAR IS NULL OR d.intake_channel = $6)
    AND ($7::VARCHAR IS NULL OR d.assigned_to_unit_id = $7)
    AND ($8::VARCHAR IS NULL OR d.current_assignee_id = $8)
    AND ($9::VARCHAR IS NULL OR d.created_by = $9)
    AND ($10::BOOLEAN IS NULL OR d.is_overdue = $10)
    AND ($11::TIMESTAMPTZ IS NULL OR d.received_date >= $11)
    AND ($12::TIMESTAMPTZ IS NULL OR d.received_date <= $12)
    AND ($13::TEXT IS NULL OR d.subject ILIKE '%' || $13 || '%')
    AND d.tenant_id = $14
ORDER BY 
    CASE WHEN $15::TEXT = 'received_date' THEN d.received_date END DESC,
    CASE WHEN $15::TEXT = 'darta_number' THEN d.darta_number END DESC,
    d.created_at DESC
LIMIT $17
OFFSET $16
`

type ListDartasParams struct {
	FiscalYearID      *string            `json:"fiscal_year_id"`
	Scope             *string            `json:"scope"`
	WardID            *string            `json:"ward_id"`
	Status            *string            `json:"status"`
	Priority          *string            `json:"priority"`
	IntakeChannel     *string            `json:"intake_channel"`
	AssignedToUnitID  *string            `json:"assigned_to_unit_id"`
	CurrentAssigneeID *string            `json:"current_assignee_id"`
	CreatedBy         *string            `json:"created_by"`
	IsOverdue         *bool              `json:"is_overdue"`
	FromDate          pgtype.Timestamptz `json:"from_date"`
	ToDate            pgtype.Timestamptz `json:"to_date"`
	Search            *string            `json:"search"`
	TenantID          string             `json:"tenant_id"`
	SortBy            string             `json:"sort_by"`
	Offset            int32              `json:"offset"`
	Limit             int32              `json:"limit"`
}

type ListDartasRow struct {
	ID                   uuid.UUID          `json:"id"`
	DartaNumber          *int32             `json:"darta_number"`
	FormattedDartaNumber *string            `json:"formatted_darta_number"`
	FiscalYearID         string             `json:"fiscal_year_id"`
	Scope                string             `json:"scope"`
	WardID               *string            `json:"ward_id"`
	Subject              string             `json:"subject"`
	ApplicantID          uuid.UUID          `json:"applicant_id"`
	IntakeChannel        string             `json:"intake_channel"`
	ReceivedDate         pgtype.Timestamptz `json:"received_date"`
	EntryDate            pgtype.Timestamptz `json:"entry_date"`
	IsBackdated          bool               `json:"is_backdated"`
	BackdateReason       *string            `json:"backdate_reason"`
	BackdateApproverID   *string            `json:"backdate_approver_id"`
	PrimaryDocumentID    uuid.UUID          `json:"primary_document_id"`
	Status               string             `json:"status"`
	Priority             string             `json:"priority"`
	ClassificationCode   *string            `json:"classification_code"`
	AssignedToUnitID     *string            `json:"assigned_to_unit_id"`
	CurrentAssigneeID    *string            `json:"current_assignee_id"`
	SlaDeadline          pgtype.Timestamptz `json:"sla_deadline"`
	IsOverdue            *bool              `json:"is_overdue"`
	CreatedBy            string             `json:"created_by"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	TenantID             string             `json:"tenant_id"`
	IdempotencyKey       *string            `json:"idempotency_key"`
	Metadata             json.RawMessage    `json:"metadata"`
	ID_2                 uuid.UUID          `json:"id_2"`
	Type                 string             `json:"type"`
	FullName             string             `json:"full_name"`
	Organization         *string            `json:"organization"`
	Email                *string            `json:"email"`
	Phone                *string            `json:"phone"`
	Address              *string            `json:"address"`
	IdentificationNumber *string            `json:"identification_number"`
	CreatedAt_2          pgtype.Timestamptz `json:"created_at_2"`
	UpdatedAt_2          pgtype.Timestamptz `json:"updated_at_2"`
}

// Complex queries with filtering
func (q *Queries) ListDartas(ctx context.Context, arg ListDartasParams) ([]ListDartasRow, error) {
	rows, err := q.db.Query(ctx, listDartas,
		arg.FiscalYearID,
		arg.Scope,
		arg.WardID,
		arg.Status,
		arg.Priority,
		arg.IntakeChannel,
		arg.AssignedToUnitID,
		arg.CurrentAssigneeID,
		arg.CreatedBy,
		arg.IsOverdue,
		arg.FromDate,
		arg.ToDate,
		arg.Search,
		arg.TenantID,
		arg.SortBy,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDartasRow
	for rows.Next() {
		var i ListDartasRow
		if err := rows.Scan(
			&i.ID,
			&i.DartaNumber,
			&i.FormattedDartaNumber,
			&i.FiscalYearID,
			&i.Scope,
			&i.WardID,
			&i.Subject,
			&i.ApplicantID,
			&i.IntakeChannel,
			&i.ReceivedDate,
			&i.EntryDate,
			&i.IsBackdated,
			&i.BackdateReason,
			&i.BackdateApproverID,
			&i.PrimaryDocumentID,
			&i.Status,
			&i.Priority,
			&i.ClassificationCode,
			&i.AssignedToUnitID,
			&i.CurrentAssigneeID,
			&i.SlaDeadline,
			&i.IsOverdue,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TenantID,
			&i.IdempotencyKey,
			&i.Metadata,
			&i.ID_2,
			&i.Type,
			&i.FullName,
			&i.Organization,
			&i.Email,
			&i.Phone,
			&i.Address,
			&i.IdentificationNumber,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDartaAssignment = `-- name: UpdateDartaAssignment :one
UPDATE dartas
SET 
    assigned_to_unit_id = $2,
    current_assignee_id = $3,
    sla_deadline = $4,
    priority = COALESCE($5, priority),
    updated_at = NOW()
WHERE id = $1
RETURNING id, darta_number, formatted_darta_number, fiscal_year_id, scope, ward_id, subject, applicant_id, intake_channel, received_date, entry_date, is_backdated, backdate_reason, backdate_approver_id, primary_document_id, status, priority, classification_code, assigned_to_unit_id, current_assignee_id, sla_deadline, is_overdue, created_by, created_at, updated_at, tenant_id, idempotency_key, metadata
`

type UpdateDartaAssignmentParams struct {
	ID                uuid.UUID          `json:"id"`
	AssignedToUnitID  *string            `json:"assigned_to_unit_id"`
	CurrentAssigneeID *string            `json:"current_assignee_id"`
	SlaDeadline       pgtype.Timestamptz `json:"sla_deadline"`
	Priority          *string            `json:"priority"`
}

func (q *Queries) UpdateDartaAssignment(ctx context.Context, arg UpdateDartaAssignmentParams) (Darta, error) {
	row := q.db.QueryRow(ctx, updateDartaAssignment,
		arg.ID,
		arg.AssignedToUnitID,
		arg.CurrentAssigneeID,
		arg.SlaDeadline,
		arg.Priority,
	)
	var i Darta
	err := row.Scan(
		&i.ID,
		&i.DartaNumber,
		&i.FormattedDartaNumber,
		&i.FiscalYearID,
		&i.Scope,
		&i.WardID,
		&i.Subject,
		&i.ApplicantID,
		&i.IntakeChannel,
		&i.ReceivedDate,
		&i.EntryDate,
		&i.IsBackdated,
		&i.BackdateReason,
		&i.BackdateApproverID,
		&i.PrimaryDocumentID,
		&i.Status,
		&i.Priority,
		&i.ClassificationCode,
		&i.AssignedToUnitID,
		&i.CurrentAssigneeID,
		&i.SlaDeadline,
		&i.IsOverdue,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
		&i.IdempotencyKey,
		&i.Metadata,
	)
	return i, err
}

const updateDartaClassification = `-- name: UpdateDartaClassification :one
UPDATE dartas
SET 
    classification_code = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, darta_number, formatted_darta_number, fiscal_year_id, scope, ward_id, subject, applicant_id, intake_channel, received_date, entry_date, is_backdated, backdate_reason, backdate_approver_id, primary_document_id, status, priority, classification_code, assigned_to_unit_id, current_assignee_id, sla_deadline, is_overdue, created_by, created_at, updated_at, tenant_id, idempotency_key, metadata
`

type UpdateDartaClassificationParams struct {
	ID                 uuid.UUID `json:"id"`
	ClassificationCode *string   `json:"classification_code"`
}

func (q *Queries) UpdateDartaClassification(ctx context.Context, arg UpdateDartaClassificationParams) (Darta, error) {
	row := q.db.QueryRow(ctx, updateDartaClassification, arg.ID, arg.ClassificationCode)
	var i Darta
	err := row.Scan(
		&i.ID,
		&i.DartaNumber,
		&i.FormattedDartaNumber,
		&i.FiscalYearID,
		&i.Scope,
		&i.WardID,
		&i.Subject,
		&i.ApplicantID,
		&i.IntakeChannel,
		&i.ReceivedDate,
		&i.EntryDate,
		&i.IsBackdated,
		&i.BackdateReason,
		&i.BackdateApproverID,
		&i.PrimaryDocumentID,
		&i.Status,
		&i.Priority,
		&i.ClassificationCode,
		&i.AssignedToUnitID,
		&i.CurrentAssigneeID,
		&i.SlaDeadline,
		&i.IsOverdue,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
		&i.IdempotencyKey,
		&i.Metadata,
	)
	return i, err
}

const updateDartaMetadata = `-- name: UpdateDartaMetadata :one
UPDATE dartas
SET 
    metadata = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, darta_number, formatted_darta_number, fiscal_year_id, scope, ward_id, subject, applicant_id, intake_channel, received_date, entry_date, is_backdated, backdate_reason, backdate_approver_id, primary_document_id, status, priority, classification_code, assigned_to_unit_id, current_assignee_id, sla_deadline, is_overdue, created_by, created_at, updated_at, tenant_id, idempotency_key, metadata
`

type UpdateDartaMetadataParams struct {
	ID       uuid.UUID       `json:"id"`
	Metadata json.RawMessage `json:"metadata"`
}

func (q *Queries) UpdateDartaMetadata(ctx context.Context, arg UpdateDartaMetadataParams) (Darta, error) {
	row := q.db.QueryRow(ctx, updateDartaMetadata, arg.ID, arg.Metadata)
	var i Darta
	err := row.Scan(
		&i.ID,
		&i.DartaNumber,
		&i.FormattedDartaNumber,
		&i.FiscalYearID,
		&i.Scope,
		&i.WardID,
		&i.Subject,
		&i.ApplicantID,
		&i.IntakeChannel,
		&i.ReceivedDate,
		&i.EntryDate,
		&i.IsBackdated,
		&i.BackdateReason,
		&i.BackdateApproverID,
		&i.PrimaryDocumentID,
		&i.Status,
		&i.Priority,
		&i.ClassificationCode,
		&i.AssignedToUnitID,
		&i.CurrentAssigneeID,
		&i.SlaDeadline,
		&i.IsOverdue,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
		&i.IdempotencyKey,
		&i.Metadata,
	)
	return i, err
}

const updateDartaNumber = `-- name: UpdateDartaNumber :one
UPDATE dartas
SET 
    darta_number = $2,
    formatted_darta_number = $3,
    updated_at = NOW()
WHERE id = $1
RETURNING id, darta_number, formatted_darta_number, fiscal_year_id, scope, ward_id, subject, applicant_id, intake_channel, received_date, entry_date, is_backdated, backdate_reason, backdate_approver_id, primary_document_id, status, priority, classification_code, assigned_to_unit_id, current_assignee_id, sla_deadline, is_overdue, created_by, created_at, updated_at, tenant_id, idempotency_key, metadata
`

type UpdateDartaNumberParams struct {
	ID                   uuid.UUID `json:"id"`
	DartaNumber          *int32    `json:"darta_number"`
	FormattedDartaNumber *string   `json:"formatted_darta_number"`
}

func (q *Queries) UpdateDartaNumber(ctx context.Context, arg UpdateDartaNumberParams) (Darta, error) {
	row := q.db.QueryRow(ctx, updateDartaNumber, arg.ID, arg.DartaNumber, arg.FormattedDartaNumber)
	var i Darta
	err := row.Scan(
		&i.ID,
		&i.DartaNumber,
		&i.FormattedDartaNumber,
		&i.FiscalYearID,
		&i.Scope,
		&i.WardID,
		&i.Subject,
		&i.ApplicantID,
		&i.IntakeChannel,
		&i.ReceivedDate,
		&i.EntryDate,
		&i.IsBackdated,
		&i.BackdateReason,
		&i.BackdateApproverID,
		&i.PrimaryDocumentID,
		&i.Status,
		&i.Priority,
		&i.ClassificationCode,
		&i.AssignedToUnitID,
		&i.CurrentAssigneeID,
		&i.SlaDeadline,
		&i.IsOverdue,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
		&i.IdempotencyKey,
		&i.Metadata,
	)
	return i, err
}

const updateDartaStatus = `-- name: UpdateDartaStatus :one
UPDATE dartas
SET status = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, darta_number, formatted_darta_number, fiscal_year_id, scope, ward_id, subject, applicant_id, intake_channel, received_date, entry_date, is_backdated, backdate_reason, backdate_approver_id, primary_document_id, status, priority, classification_code, assigned_to_unit_id, current_assignee_id, sla_deadline, is_overdue, created_by, created_at, updated_at, tenant_id, idempotency_key, metadata
`

type UpdateDartaStatusParams struct {
	ID     uuid.UUID `json:"id"`
	Status string    `json:"status"`
}

func (q *Queries) UpdateDartaStatus(ctx context.Context, arg UpdateDartaStatusParams) (Darta, error) {
	row := q.db.QueryRow(ctx, updateDartaStatus, arg.ID, arg.Status)
	var i Darta
	err := row.Scan(
		&i.ID,
		&i.DartaNumber,
		&i.FormattedDartaNumber,
		&i.FiscalYearID,
		&i.Scope,
		&i.WardID,
		&i.Subject,
		&i.ApplicantID,
		&i.IntakeChannel,
		&i.ReceivedDate,
		&i.EntryDate,
		&i.IsBackdated,
		&i.BackdateReason,
		&i.BackdateApproverID,
		&i.PrimaryDocumentID,
		&i.Status,
		&i.Priority,
		&i.ClassificationCode,
		&i.AssignedToUnitID,
		&i.CurrentAssigneeID,
		&i.SlaDeadline,
		&i.IsOverdue,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
		&i.IdempotencyKey,
		&i.Metadata,
	)
	return i, err
}

const voidDarta = `-- name: VoidDarta :one
UPDATE dartas
SET 
    status = 'VOIDED',
    updated_at = NOW()
WHERE id = $1
RETURNING id, darta_number, formatted_darta_number, fiscal_year_id, scope, ward_id, subject, applicant_id, intake_channel, received_date, entry_date, is_backdated, backdate_reason, backdate_approver_id, primary_document_id, status, priority, classification_code, assigned_to_unit_id, current_assignee_id, sla_deadline, is_overdue, created_by, created_at, updated_at, tenant_id, idempotency_key, metadata
`

func (q *Queries) VoidDarta(ctx context.Context, id uuid.UUID) (Darta, error) {
	row := q.db.QueryRow(ctx, voidDarta, id)
	var i Darta
	err := row.Scan(
		&i.ID,
		&i.DartaNumber,
		&i.FormattedDartaNumber,
		&i.FiscalYearID,
		&i.Scope,
		&i.WardID,
		&i.Subject,
		&i.ApplicantID,
		&i.IntakeChannel,
		&i.ReceivedDate,
		&i.EntryDate,
		&i.IsBackdated,
		&i.BackdateReason,
		&i.BackdateApproverID,
		&i.PrimaryDocumentID,
		&i.Status,
		&i.Priority,
		&i.ClassificationCode,
		&i.AssignedToUnitID,
		&i.CurrentAssigneeID,
		&i.SlaDeadline,
		&i.IsOverdue,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
		&i.IdempotencyKey,
		&i.Metadata,
	)
	return i, err
}
