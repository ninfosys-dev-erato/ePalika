// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: chalanis.sql

package db

import (
	"context"
	"encoding/json"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const closeChalani = `-- name: CloseChalani :one
UPDATE chalanis
SET 
    status = 'CLOSED',
    updated_at = NOW()
WHERE id = $1
RETURNING id, chalani_number, formatted_chalani_number, fiscal_year_id, scope, ward_id, subject, body, template_id, linked_darta_id, recipient_id, status, is_fully_approved, dispatch_channel, dispatched_at, dispatched_by, tracking_id, courier_name, is_acknowledged, acknowledged_at, acknowledged_by, acknowledgement_proof_id, delivered_at, delivered_proof_id, superseded_by_id, supersedes_id, created_by, created_at, updated_at, tenant_id, idempotency_key, metadata
`

func (q *Queries) CloseChalani(ctx context.Context, id uuid.UUID) (Chalani, error) {
	row := q.db.QueryRow(ctx, closeChalani, id)
	var i Chalani
	err := row.Scan(
		&i.ID,
		&i.ChalaniNumber,
		&i.FormattedChalaniNumber,
		&i.FiscalYearID,
		&i.Scope,
		&i.WardID,
		&i.Subject,
		&i.Body,
		&i.TemplateID,
		&i.LinkedDartaID,
		&i.RecipientID,
		&i.Status,
		&i.IsFullyApproved,
		&i.DispatchChannel,
		&i.DispatchedAt,
		&i.DispatchedBy,
		&i.TrackingID,
		&i.CourierName,
		&i.IsAcknowledged,
		&i.AcknowledgedAt,
		&i.AcknowledgedBy,
		&i.AcknowledgementProofID,
		&i.DeliveredAt,
		&i.DeliveredProofID,
		&i.SupersededByID,
		&i.SupersedesID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
		&i.IdempotencyKey,
		&i.Metadata,
	)
	return i, err
}

const countChalanis = `-- name: CountChalanis :one
SELECT COUNT(*)
FROM chalanis c
WHERE
    ($1::VARCHAR IS NULL OR c.fiscal_year_id = $1)
    AND ($2::VARCHAR IS NULL OR c.status = $2)
    AND ($3::UUID IS NULL OR c.linked_darta_id = $3)
    AND ($4::TIMESTAMPTZ IS NULL OR c.created_at >= $4)
    AND ($5::TIMESTAMPTZ IS NULL OR c.created_at <= $5)
    AND c.tenant_id = $6
`

type CountChalanisParams struct {
	FiscalYearID  *string            `json:"fiscal_year_id"`
	Status        *string            `json:"status"`
	LinkedDartaID pgtype.UUID        `json:"linked_darta_id"`
	FromDate      pgtype.Timestamptz `json:"from_date"`
	ToDate        pgtype.Timestamptz `json:"to_date"`
	TenantID      string             `json:"tenant_id"`
}

func (q *Queries) CountChalanis(ctx context.Context, arg CountChalanisParams) (int64, error) {
	row := q.db.QueryRow(ctx, countChalanis,
		arg.FiscalYearID,
		arg.Status,
		arg.LinkedDartaID,
		arg.FromDate,
		arg.ToDate,
		arg.TenantID,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createChalani = `-- name: CreateChalani :one

INSERT INTO chalanis (
    fiscal_year_id,
    scope,
    ward_id,
    subject,
    body,
    template_id,
    linked_darta_id,
    recipient_id,
    status,
    created_by,
    tenant_id,
    idempotency_key,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
) RETURNING id, chalani_number, formatted_chalani_number, fiscal_year_id, scope, ward_id, subject, body, template_id, linked_darta_id, recipient_id, status, is_fully_approved, dispatch_channel, dispatched_at, dispatched_by, tracking_id, courier_name, is_acknowledged, acknowledged_at, acknowledged_by, acknowledgement_proof_id, delivered_at, delivered_proof_id, superseded_by_id, supersedes_id, created_by, created_at, updated_at, tenant_id, idempotency_key, metadata
`

type CreateChalaniParams struct {
	FiscalYearID   string          `json:"fiscal_year_id"`
	Scope          string          `json:"scope"`
	WardID         *string         `json:"ward_id"`
	Subject        string          `json:"subject"`
	Body           string          `json:"body"`
	TemplateID     *string         `json:"template_id"`
	LinkedDartaID  *uuid.UUID      `json:"linked_darta_id"`
	RecipientID    uuid.UUID       `json:"recipient_id"`
	Status         string          `json:"status"`
	CreatedBy      string          `json:"created_by"`
	TenantID       string          `json:"tenant_id"`
	IdempotencyKey *string         `json:"idempotency_key"`
	Metadata       json.RawMessage `json:"metadata"`
}

// ============================================================================
// CHALANIS - Outgoing correspondence
// ============================================================================
func (q *Queries) CreateChalani(ctx context.Context, arg CreateChalaniParams) (Chalani, error) {
	row := q.db.QueryRow(ctx, createChalani,
		arg.FiscalYearID,
		arg.Scope,
		arg.WardID,
		arg.Subject,
		arg.Body,
		arg.TemplateID,
		arg.LinkedDartaID,
		arg.RecipientID,
		arg.Status,
		arg.CreatedBy,
		arg.TenantID,
		arg.IdempotencyKey,
		arg.Metadata,
	)
	var i Chalani
	err := row.Scan(
		&i.ID,
		&i.ChalaniNumber,
		&i.FormattedChalaniNumber,
		&i.FiscalYearID,
		&i.Scope,
		&i.WardID,
		&i.Subject,
		&i.Body,
		&i.TemplateID,
		&i.LinkedDartaID,
		&i.RecipientID,
		&i.Status,
		&i.IsFullyApproved,
		&i.DispatchChannel,
		&i.DispatchedAt,
		&i.DispatchedBy,
		&i.TrackingID,
		&i.CourierName,
		&i.IsAcknowledged,
		&i.AcknowledgedAt,
		&i.AcknowledgedBy,
		&i.AcknowledgementProofID,
		&i.DeliveredAt,
		&i.DeliveredProofID,
		&i.SupersededByID,
		&i.SupersedesID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
		&i.IdempotencyKey,
		&i.Metadata,
	)
	return i, err
}

const getAcknowledgementRate = `-- name: GetAcknowledgementRate :one
SELECT 
    COUNT(*)::FLOAT as total,
    SUM(CASE WHEN is_acknowledged THEN 1 ELSE 0 END)::FLOAT as acknowledged
FROM chalanis
WHERE tenant_id = $1
  AND status IN ('DISPATCHED', 'ACKNOWLEDGED', 'DELIVERED')
  AND ($2::VARCHAR IS NULL OR fiscal_year_id = $2)
`

type GetAcknowledgementRateParams struct {
	TenantID     string  `json:"tenant_id"`
	FiscalYearID *string `json:"fiscal_year_id"`
}

type GetAcknowledgementRateRow struct {
	Total        float64 `json:"total"`
	Acknowledged float64 `json:"acknowledged"`
}

func (q *Queries) GetAcknowledgementRate(ctx context.Context, arg GetAcknowledgementRateParams) (GetAcknowledgementRateRow, error) {
	row := q.db.QueryRow(ctx, getAcknowledgementRate, arg.TenantID, arg.FiscalYearID)
	var i GetAcknowledgementRateRow
	err := row.Scan(&i.Total, &i.Acknowledged)
	return i, err
}

const getChalani = `-- name: GetChalani :one
SELECT c.id, c.chalani_number, c.formatted_chalani_number, c.fiscal_year_id, c.scope, c.ward_id, c.subject, c.body, c.template_id, c.linked_darta_id, c.recipient_id, c.status, c.is_fully_approved, c.dispatch_channel, c.dispatched_at, c.dispatched_by, c.tracking_id, c.courier_name, c.is_acknowledged, c.acknowledged_at, c.acknowledged_by, c.acknowledgement_proof_id, c.delivered_at, c.delivered_proof_id, c.superseded_by_id, c.supersedes_id, c.created_by, c.created_at, c.updated_at, c.tenant_id, c.idempotency_key, c.metadata, r.id, r.type, r.name, r.organization, r.email, r.phone, r.address, r.created_at, r.updated_at
FROM chalanis c
JOIN recipients r ON c.recipient_id = r.id
WHERE c.id = $1
`

type GetChalaniRow struct {
	ID                     uuid.UUID          `json:"id"`
	ChalaniNumber          *int32             `json:"chalani_number"`
	FormattedChalaniNumber *string            `json:"formatted_chalani_number"`
	FiscalYearID           string             `json:"fiscal_year_id"`
	Scope                  string             `json:"scope"`
	WardID                 *string            `json:"ward_id"`
	Subject                string             `json:"subject"`
	Body                   string             `json:"body"`
	TemplateID             *string            `json:"template_id"`
	LinkedDartaID          *uuid.UUID         `json:"linked_darta_id"`
	RecipientID            uuid.UUID          `json:"recipient_id"`
	Status                 string             `json:"status"`
	IsFullyApproved        bool               `json:"is_fully_approved"`
	DispatchChannel        *string            `json:"dispatch_channel"`
	DispatchedAt           pgtype.Timestamptz `json:"dispatched_at"`
	DispatchedBy           *string            `json:"dispatched_by"`
	TrackingID             *string            `json:"tracking_id"`
	CourierName            *string            `json:"courier_name"`
	IsAcknowledged         bool               `json:"is_acknowledged"`
	AcknowledgedAt         pgtype.Timestamptz `json:"acknowledged_at"`
	AcknowledgedBy         *string            `json:"acknowledged_by"`
	AcknowledgementProofID pgtype.UUID        `json:"acknowledgement_proof_id"`
	DeliveredAt            pgtype.Timestamptz `json:"delivered_at"`
	DeliveredProofID       pgtype.UUID        `json:"delivered_proof_id"`
	SupersededByID         pgtype.UUID        `json:"superseded_by_id"`
	SupersedesID           pgtype.UUID        `json:"supersedes_id"`
	CreatedBy              string             `json:"created_by"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
	TenantID               string             `json:"tenant_id"`
	IdempotencyKey         *string            `json:"idempotency_key"`
	Metadata               json.RawMessage    `json:"metadata"`
	ID_2                   uuid.UUID          `json:"id_2"`
	Type                   string             `json:"type"`
	Name                   string             `json:"name"`
	Organization           *string            `json:"organization"`
	Email                  *string            `json:"email"`
	Phone                  *string            `json:"phone"`
	Address                string             `json:"address"`
	CreatedAt_2            pgtype.Timestamptz `json:"created_at_2"`
	UpdatedAt_2            pgtype.Timestamptz `json:"updated_at_2"`
}

func (q *Queries) GetChalani(ctx context.Context, id uuid.UUID) (GetChalaniRow, error) {
	row := q.db.QueryRow(ctx, getChalani, id)
	var i GetChalaniRow
	err := row.Scan(
		&i.ID,
		&i.ChalaniNumber,
		&i.FormattedChalaniNumber,
		&i.FiscalYearID,
		&i.Scope,
		&i.WardID,
		&i.Subject,
		&i.Body,
		&i.TemplateID,
		&i.LinkedDartaID,
		&i.RecipientID,
		&i.Status,
		&i.IsFullyApproved,
		&i.DispatchChannel,
		&i.DispatchedAt,
		&i.DispatchedBy,
		&i.TrackingID,
		&i.CourierName,
		&i.IsAcknowledged,
		&i.AcknowledgedAt,
		&i.AcknowledgedBy,
		&i.AcknowledgementProofID,
		&i.DeliveredAt,
		&i.DeliveredProofID,
		&i.SupersededByID,
		&i.SupersedesID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
		&i.IdempotencyKey,
		&i.Metadata,
		&i.ID_2,
		&i.Type,
		&i.Name,
		&i.Organization,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
	)
	return i, err
}

const getChalaniByIdempotencyKey = `-- name: GetChalaniByIdempotencyKey :one
SELECT id, chalani_number, formatted_chalani_number, fiscal_year_id, scope, ward_id, subject, body, template_id, linked_darta_id, recipient_id, status, is_fully_approved, dispatch_channel, dispatched_at, dispatched_by, tracking_id, courier_name, is_acknowledged, acknowledged_at, acknowledged_by, acknowledgement_proof_id, delivered_at, delivered_proof_id, superseded_by_id, supersedes_id, created_by, created_at, updated_at, tenant_id, idempotency_key, metadata FROM chalanis
WHERE idempotency_key = $1 AND tenant_id = $2
`

type GetChalaniByIdempotencyKeyParams struct {
	IdempotencyKey *string `json:"idempotency_key"`
	TenantID       string  `json:"tenant_id"`
}

func (q *Queries) GetChalaniByIdempotencyKey(ctx context.Context, arg GetChalaniByIdempotencyKeyParams) (Chalani, error) {
	row := q.db.QueryRow(ctx, getChalaniByIdempotencyKey, arg.IdempotencyKey, arg.TenantID)
	var i Chalani
	err := row.Scan(
		&i.ID,
		&i.ChalaniNumber,
		&i.FormattedChalaniNumber,
		&i.FiscalYearID,
		&i.Scope,
		&i.WardID,
		&i.Subject,
		&i.Body,
		&i.TemplateID,
		&i.LinkedDartaID,
		&i.RecipientID,
		&i.Status,
		&i.IsFullyApproved,
		&i.DispatchChannel,
		&i.DispatchedAt,
		&i.DispatchedBy,
		&i.TrackingID,
		&i.CourierName,
		&i.IsAcknowledged,
		&i.AcknowledgedAt,
		&i.AcknowledgedBy,
		&i.AcknowledgementProofID,
		&i.DeliveredAt,
		&i.DeliveredProofID,
		&i.SupersededByID,
		&i.SupersedesID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
		&i.IdempotencyKey,
		&i.Metadata,
	)
	return i, err
}

const getChalaniByNumber = `-- name: GetChalaniByNumber :one
SELECT c.id, c.chalani_number, c.formatted_chalani_number, c.fiscal_year_id, c.scope, c.ward_id, c.subject, c.body, c.template_id, c.linked_darta_id, c.recipient_id, c.status, c.is_fully_approved, c.dispatch_channel, c.dispatched_at, c.dispatched_by, c.tracking_id, c.courier_name, c.is_acknowledged, c.acknowledged_at, c.acknowledged_by, c.acknowledgement_proof_id, c.delivered_at, c.delivered_proof_id, c.superseded_by_id, c.supersedes_id, c.created_by, c.created_at, c.updated_at, c.tenant_id, c.idempotency_key, c.metadata, r.id, r.type, r.name, r.organization, r.email, r.phone, r.address, r.created_at, r.updated_at
FROM chalanis c
JOIN recipients r ON c.recipient_id = r.id
WHERE c.chalani_number = $1 
  AND c.fiscal_year_id = $2
  AND c.scope = $3
  AND (c.ward_id = $4 OR (c.ward_id IS NULL AND $4::VARCHAR IS NULL))
`

type GetChalaniByNumberParams struct {
	ChalaniNumber *int32  `json:"chalani_number"`
	FiscalYearID  string  `json:"fiscal_year_id"`
	Scope         string  `json:"scope"`
	WardID        *string `json:"ward_id"`
}

type GetChalaniByNumberRow struct {
	ID                     uuid.UUID          `json:"id"`
	ChalaniNumber          *int32             `json:"chalani_number"`
	FormattedChalaniNumber *string            `json:"formatted_chalani_number"`
	FiscalYearID           string             `json:"fiscal_year_id"`
	Scope                  string             `json:"scope"`
	WardID                 *string            `json:"ward_id"`
	Subject                string             `json:"subject"`
	Body                   string             `json:"body"`
	TemplateID             *string            `json:"template_id"`
	LinkedDartaID          *uuid.UUID         `json:"linked_darta_id"`
	RecipientID            uuid.UUID          `json:"recipient_id"`
	Status                 string             `json:"status"`
	IsFullyApproved        bool               `json:"is_fully_approved"`
	DispatchChannel        *string            `json:"dispatch_channel"`
	DispatchedAt           pgtype.Timestamptz `json:"dispatched_at"`
	DispatchedBy           *string            `json:"dispatched_by"`
	TrackingID             *string            `json:"tracking_id"`
	CourierName            *string            `json:"courier_name"`
	IsAcknowledged         bool               `json:"is_acknowledged"`
	AcknowledgedAt         pgtype.Timestamptz `json:"acknowledged_at"`
	AcknowledgedBy         *string            `json:"acknowledged_by"`
	AcknowledgementProofID pgtype.UUID        `json:"acknowledgement_proof_id"`
	DeliveredAt            pgtype.Timestamptz `json:"delivered_at"`
	DeliveredProofID       pgtype.UUID        `json:"delivered_proof_id"`
	SupersededByID         pgtype.UUID        `json:"superseded_by_id"`
	SupersedesID           pgtype.UUID        `json:"supersedes_id"`
	CreatedBy              string             `json:"created_by"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
	TenantID               string             `json:"tenant_id"`
	IdempotencyKey         *string            `json:"idempotency_key"`
	Metadata               json.RawMessage    `json:"metadata"`
	ID_2                   uuid.UUID          `json:"id_2"`
	Type                   string             `json:"type"`
	Name                   string             `json:"name"`
	Organization           *string            `json:"organization"`
	Email                  *string            `json:"email"`
	Phone                  *string            `json:"phone"`
	Address                string             `json:"address"`
	CreatedAt_2            pgtype.Timestamptz `json:"created_at_2"`
	UpdatedAt_2            pgtype.Timestamptz `json:"updated_at_2"`
}

func (q *Queries) GetChalaniByNumber(ctx context.Context, arg GetChalaniByNumberParams) (GetChalaniByNumberRow, error) {
	row := q.db.QueryRow(ctx, getChalaniByNumber,
		arg.ChalaniNumber,
		arg.FiscalYearID,
		arg.Scope,
		arg.WardID,
	)
	var i GetChalaniByNumberRow
	err := row.Scan(
		&i.ID,
		&i.ChalaniNumber,
		&i.FormattedChalaniNumber,
		&i.FiscalYearID,
		&i.Scope,
		&i.WardID,
		&i.Subject,
		&i.Body,
		&i.TemplateID,
		&i.LinkedDartaID,
		&i.RecipientID,
		&i.Status,
		&i.IsFullyApproved,
		&i.DispatchChannel,
		&i.DispatchedAt,
		&i.DispatchedBy,
		&i.TrackingID,
		&i.CourierName,
		&i.IsAcknowledged,
		&i.AcknowledgedAt,
		&i.AcknowledgedBy,
		&i.AcknowledgementProofID,
		&i.DeliveredAt,
		&i.DeliveredProofID,
		&i.SupersededByID,
		&i.SupersedesID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
		&i.IdempotencyKey,
		&i.Metadata,
		&i.ID_2,
		&i.Type,
		&i.Name,
		&i.Organization,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
	)
	return i, err
}

const getChalaniSimple = `-- name: GetChalaniSimple :one
SELECT id, chalani_number, formatted_chalani_number, fiscal_year_id, scope, ward_id, subject, body, template_id, linked_darta_id, recipient_id, status, is_fully_approved, dispatch_channel, dispatched_at, dispatched_by, tracking_id, courier_name, is_acknowledged, acknowledged_at, acknowledged_by, acknowledgement_proof_id, delivered_at, delivered_proof_id, superseded_by_id, supersedes_id, created_by, created_at, updated_at, tenant_id, idempotency_key, metadata FROM chalanis WHERE id = $1
`

func (q *Queries) GetChalaniSimple(ctx context.Context, id uuid.UUID) (Chalani, error) {
	row := q.db.QueryRow(ctx, getChalaniSimple, id)
	var i Chalani
	err := row.Scan(
		&i.ID,
		&i.ChalaniNumber,
		&i.FormattedChalaniNumber,
		&i.FiscalYearID,
		&i.Scope,
		&i.WardID,
		&i.Subject,
		&i.Body,
		&i.TemplateID,
		&i.LinkedDartaID,
		&i.RecipientID,
		&i.Status,
		&i.IsFullyApproved,
		&i.DispatchChannel,
		&i.DispatchedAt,
		&i.DispatchedBy,
		&i.TrackingID,
		&i.CourierName,
		&i.IsAcknowledged,
		&i.AcknowledgedAt,
		&i.AcknowledgedBy,
		&i.AcknowledgementProofID,
		&i.DeliveredAt,
		&i.DeliveredProofID,
		&i.SupersededByID,
		&i.SupersedesID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
		&i.IdempotencyKey,
		&i.Metadata,
	)
	return i, err
}

const getChalaniStatsByChannel = `-- name: GetChalaniStatsByChannel :many
SELECT dispatch_channel, COUNT(*) as count
FROM chalanis
WHERE tenant_id = $1
  AND ($2::VARCHAR IS NULL OR fiscal_year_id = $2)
  AND dispatch_channel IS NOT NULL
GROUP BY dispatch_channel
`

type GetChalaniStatsByChannelParams struct {
	TenantID     string  `json:"tenant_id"`
	FiscalYearID *string `json:"fiscal_year_id"`
}

type GetChalaniStatsByChannelRow struct {
	DispatchChannel *string `json:"dispatch_channel"`
	Count           int64   `json:"count"`
}

func (q *Queries) GetChalaniStatsByChannel(ctx context.Context, arg GetChalaniStatsByChannelParams) ([]GetChalaniStatsByChannelRow, error) {
	rows, err := q.db.Query(ctx, getChalaniStatsByChannel, arg.TenantID, arg.FiscalYearID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChalaniStatsByChannelRow
	for rows.Next() {
		var i GetChalaniStatsByChannelRow
		if err := rows.Scan(&i.DispatchChannel, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChalaniStatsByStatus = `-- name: GetChalaniStatsByStatus :many
SELECT status, COUNT(*) as count
FROM chalanis
WHERE tenant_id = $1
  AND ($2::VARCHAR IS NULL OR fiscal_year_id = $2)
GROUP BY status
`

type GetChalaniStatsByStatusParams struct {
	TenantID     string  `json:"tenant_id"`
	FiscalYearID *string `json:"fiscal_year_id"`
}

type GetChalaniStatsByStatusRow struct {
	Status string `json:"status"`
	Count  int64  `json:"count"`
}

// Statistics
func (q *Queries) GetChalaniStatsByStatus(ctx context.Context, arg GetChalaniStatsByStatusParams) ([]GetChalaniStatsByStatusRow, error) {
	rows, err := q.db.Query(ctx, getChalaniStatsByStatus, arg.TenantID, arg.FiscalYearID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChalaniStatsByStatusRow
	for rows.Next() {
		var i GetChalaniStatsByStatusRow
		if err := rows.Scan(&i.Status, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMyChalani = `-- name: GetMyChalani :many
SELECT c.id, c.chalani_number, c.formatted_chalani_number, c.fiscal_year_id, c.scope, c.ward_id, c.subject, c.body, c.template_id, c.linked_darta_id, c.recipient_id, c.status, c.is_fully_approved, c.dispatch_channel, c.dispatched_at, c.dispatched_by, c.tracking_id, c.courier_name, c.is_acknowledged, c.acknowledged_at, c.acknowledged_by, c.acknowledgement_proof_id, c.delivered_at, c.delivered_proof_id, c.superseded_by_id, c.supersedes_id, c.created_by, c.created_at, c.updated_at, c.tenant_id, c.idempotency_key, c.metadata, r.id, r.type, r.name, r.organization, r.email, r.phone, r.address, r.created_at, r.updated_at
FROM chalanis c
JOIN recipients r ON c.recipient_id = r.id
WHERE c.created_by = $1
  AND ($5::VARCHAR IS NULL OR c.status = $5)
  AND c.tenant_id = $2
ORDER BY c.created_at DESC
LIMIT $3 OFFSET $4
`

type GetMyChalaniParams struct {
	CreatedBy string  `json:"created_by"`
	TenantID  string  `json:"tenant_id"`
	Limit     int32   `json:"limit"`
	Offset    int32   `json:"offset"`
	Status    *string `json:"status"`
}

type GetMyChalaniRow struct {
	ID                     uuid.UUID          `json:"id"`
	ChalaniNumber          *int32             `json:"chalani_number"`
	FormattedChalaniNumber *string            `json:"formatted_chalani_number"`
	FiscalYearID           string             `json:"fiscal_year_id"`
	Scope                  string             `json:"scope"`
	WardID                 *string            `json:"ward_id"`
	Subject                string             `json:"subject"`
	Body                   string             `json:"body"`
	TemplateID             *string            `json:"template_id"`
	LinkedDartaID          *uuid.UUID         `json:"linked_darta_id"`
	RecipientID            uuid.UUID          `json:"recipient_id"`
	Status                 string             `json:"status"`
	IsFullyApproved        bool               `json:"is_fully_approved"`
	DispatchChannel        *string            `json:"dispatch_channel"`
	DispatchedAt           pgtype.Timestamptz `json:"dispatched_at"`
	DispatchedBy           *string            `json:"dispatched_by"`
	TrackingID             *string            `json:"tracking_id"`
	CourierName            *string            `json:"courier_name"`
	IsAcknowledged         bool               `json:"is_acknowledged"`
	AcknowledgedAt         pgtype.Timestamptz `json:"acknowledged_at"`
	AcknowledgedBy         *string            `json:"acknowledged_by"`
	AcknowledgementProofID pgtype.UUID        `json:"acknowledgement_proof_id"`
	DeliveredAt            pgtype.Timestamptz `json:"delivered_at"`
	DeliveredProofID       pgtype.UUID        `json:"delivered_proof_id"`
	SupersededByID         pgtype.UUID        `json:"superseded_by_id"`
	SupersedesID           pgtype.UUID        `json:"supersedes_id"`
	CreatedBy              string             `json:"created_by"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
	TenantID               string             `json:"tenant_id"`
	IdempotencyKey         *string            `json:"idempotency_key"`
	Metadata               json.RawMessage    `json:"metadata"`
	ID_2                   uuid.UUID          `json:"id_2"`
	Type                   string             `json:"type"`
	Name                   string             `json:"name"`
	Organization           *string            `json:"organization"`
	Email                  *string            `json:"email"`
	Phone                  *string            `json:"phone"`
	Address                string             `json:"address"`
	CreatedAt_2            pgtype.Timestamptz `json:"created_at_2"`
	UpdatedAt_2            pgtype.Timestamptz `json:"updated_at_2"`
}

func (q *Queries) GetMyChalani(ctx context.Context, arg GetMyChalaniParams) ([]GetMyChalaniRow, error) {
	rows, err := q.db.Query(ctx, getMyChalani,
		arg.CreatedBy,
		arg.TenantID,
		arg.Limit,
		arg.Offset,
		arg.Status,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMyChalaniRow
	for rows.Next() {
		var i GetMyChalaniRow
		if err := rows.Scan(
			&i.ID,
			&i.ChalaniNumber,
			&i.FormattedChalaniNumber,
			&i.FiscalYearID,
			&i.Scope,
			&i.WardID,
			&i.Subject,
			&i.Body,
			&i.TemplateID,
			&i.LinkedDartaID,
			&i.RecipientID,
			&i.Status,
			&i.IsFullyApproved,
			&i.DispatchChannel,
			&i.DispatchedAt,
			&i.DispatchedBy,
			&i.TrackingID,
			&i.CourierName,
			&i.IsAcknowledged,
			&i.AcknowledgedAt,
			&i.AcknowledgedBy,
			&i.AcknowledgementProofID,
			&i.DeliveredAt,
			&i.DeliveredProofID,
			&i.SupersededByID,
			&i.SupersedesID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TenantID,
			&i.IdempotencyKey,
			&i.Metadata,
			&i.ID_2,
			&i.Type,
			&i.Name,
			&i.Organization,
			&i.Email,
			&i.Phone,
			&i.Address,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNextChalaniNumber = `-- name: GetNextChalaniNumber :one
SELECT COALESCE(MAX(chalani_number), 0) + 1 as next_number
FROM chalanis
WHERE fiscal_year_id = $1
  AND scope = $2
  AND (ward_id = $4 OR (ward_id IS NULL AND $4::VARCHAR IS NULL))
  AND tenant_id = $3
`

type GetNextChalaniNumberParams struct {
	FiscalYearID string  `json:"fiscal_year_id"`
	Scope        string  `json:"scope"`
	TenantID     string  `json:"tenant_id"`
	WardID       *string `json:"ward_id"`
}

func (q *Queries) GetNextChalaniNumber(ctx context.Context, arg GetNextChalaniNumberParams) (int32, error) {
	row := q.db.QueryRow(ctx, getNextChalaniNumber,
		arg.FiscalYearID,
		arg.Scope,
		arg.TenantID,
		arg.WardID,
	)
	var next_number int32
	err := row.Scan(&next_number)
	return next_number, err
}

const listChalanis = `-- name: ListChalanis :many
SELECT c.id, c.chalani_number, c.formatted_chalani_number, c.fiscal_year_id, c.scope, c.ward_id, c.subject, c.body, c.template_id, c.linked_darta_id, c.recipient_id, c.status, c.is_fully_approved, c.dispatch_channel, c.dispatched_at, c.dispatched_by, c.tracking_id, c.courier_name, c.is_acknowledged, c.acknowledged_at, c.acknowledged_by, c.acknowledgement_proof_id, c.delivered_at, c.delivered_proof_id, c.superseded_by_id, c.supersedes_id, c.created_by, c.created_at, c.updated_at, c.tenant_id, c.idempotency_key, c.metadata, r.id, r.type, r.name, r.organization, r.email, r.phone, r.address, r.created_at, r.updated_at
FROM chalanis c
JOIN recipients r ON c.recipient_id = r.id
WHERE
    ($1::VARCHAR IS NULL OR c.fiscal_year_id = $1)
    AND ($2::VARCHAR IS NULL OR c.scope = $2)
    AND ($3::VARCHAR IS NULL OR c.ward_id = $3)
    AND ($4::VARCHAR IS NULL OR c.status = $4)
    AND ($5::VARCHAR IS NULL OR c.dispatch_channel = $5)
    AND ($6::UUID IS NULL OR c.linked_darta_id = $6)
    AND ($7::VARCHAR IS NULL OR c.created_by = $7)
    AND ($8::TIMESTAMPTZ IS NULL OR c.created_at >= $8)
    AND ($9::TIMESTAMPTZ IS NULL OR c.created_at <= $9)
    AND ($10::TEXT IS NULL OR c.subject ILIKE '%' || $10 || '%')
    AND c.tenant_id = $11
ORDER BY c.created_at DESC
LIMIT $13
OFFSET $12
`

type ListChalanisParams struct {
	FiscalYearID    *string            `json:"fiscal_year_id"`
	Scope           *string            `json:"scope"`
	WardID          *string            `json:"ward_id"`
	Status          *string            `json:"status"`
	DispatchChannel *string            `json:"dispatch_channel"`
	LinkedDartaID   pgtype.UUID        `json:"linked_darta_id"`
	CreatedBy       *string            `json:"created_by"`
	FromDate        pgtype.Timestamptz `json:"from_date"`
	ToDate          pgtype.Timestamptz `json:"to_date"`
	Search          *string            `json:"search"`
	TenantID        string             `json:"tenant_id"`
	Offset          int32              `json:"offset"`
	Limit           int32              `json:"limit"`
}

type ListChalanisRow struct {
	ID                     uuid.UUID          `json:"id"`
	ChalaniNumber          *int32             `json:"chalani_number"`
	FormattedChalaniNumber *string            `json:"formatted_chalani_number"`
	FiscalYearID           string             `json:"fiscal_year_id"`
	Scope                  string             `json:"scope"`
	WardID                 *string            `json:"ward_id"`
	Subject                string             `json:"subject"`
	Body                   string             `json:"body"`
	TemplateID             *string            `json:"template_id"`
	LinkedDartaID          *uuid.UUID         `json:"linked_darta_id"`
	RecipientID            uuid.UUID          `json:"recipient_id"`
	Status                 string             `json:"status"`
	IsFullyApproved        bool               `json:"is_fully_approved"`
	DispatchChannel        *string            `json:"dispatch_channel"`
	DispatchedAt           pgtype.Timestamptz `json:"dispatched_at"`
	DispatchedBy           *string            `json:"dispatched_by"`
	TrackingID             *string            `json:"tracking_id"`
	CourierName            *string            `json:"courier_name"`
	IsAcknowledged         bool               `json:"is_acknowledged"`
	AcknowledgedAt         pgtype.Timestamptz `json:"acknowledged_at"`
	AcknowledgedBy         *string            `json:"acknowledged_by"`
	AcknowledgementProofID pgtype.UUID        `json:"acknowledgement_proof_id"`
	DeliveredAt            pgtype.Timestamptz `json:"delivered_at"`
	DeliveredProofID       pgtype.UUID        `json:"delivered_proof_id"`
	SupersededByID         pgtype.UUID        `json:"superseded_by_id"`
	SupersedesID           pgtype.UUID        `json:"supersedes_id"`
	CreatedBy              string             `json:"created_by"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
	TenantID               string             `json:"tenant_id"`
	IdempotencyKey         *string            `json:"idempotency_key"`
	Metadata               json.RawMessage    `json:"metadata"`
	ID_2                   uuid.UUID          `json:"id_2"`
	Type                   string             `json:"type"`
	Name                   string             `json:"name"`
	Organization           *string            `json:"organization"`
	Email                  *string            `json:"email"`
	Phone                  *string            `json:"phone"`
	Address                string             `json:"address"`
	CreatedAt_2            pgtype.Timestamptz `json:"created_at_2"`
	UpdatedAt_2            pgtype.Timestamptz `json:"updated_at_2"`
}

// List with filtering
func (q *Queries) ListChalanis(ctx context.Context, arg ListChalanisParams) ([]ListChalanisRow, error) {
	rows, err := q.db.Query(ctx, listChalanis,
		arg.FiscalYearID,
		arg.Scope,
		arg.WardID,
		arg.Status,
		arg.DispatchChannel,
		arg.LinkedDartaID,
		arg.CreatedBy,
		arg.FromDate,
		arg.ToDate,
		arg.Search,
		arg.TenantID,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListChalanisRow
	for rows.Next() {
		var i ListChalanisRow
		if err := rows.Scan(
			&i.ID,
			&i.ChalaniNumber,
			&i.FormattedChalaniNumber,
			&i.FiscalYearID,
			&i.Scope,
			&i.WardID,
			&i.Subject,
			&i.Body,
			&i.TemplateID,
			&i.LinkedDartaID,
			&i.RecipientID,
			&i.Status,
			&i.IsFullyApproved,
			&i.DispatchChannel,
			&i.DispatchedAt,
			&i.DispatchedBy,
			&i.TrackingID,
			&i.CourierName,
			&i.IsAcknowledged,
			&i.AcknowledgedAt,
			&i.AcknowledgedBy,
			&i.AcknowledgementProofID,
			&i.DeliveredAt,
			&i.DeliveredProofID,
			&i.SupersededByID,
			&i.SupersedesID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TenantID,
			&i.IdempotencyKey,
			&i.Metadata,
			&i.ID_2,
			&i.Type,
			&i.Name,
			&i.Organization,
			&i.Email,
			&i.Phone,
			&i.Address,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markChalaniDelivered = `-- name: MarkChalaniDelivered :one
UPDATE chalanis
SET 
    delivered_at = $2,
    delivered_proof_id = $3,
    status = 'DELIVERED',
    updated_at = NOW()
WHERE id = $1
RETURNING id, chalani_number, formatted_chalani_number, fiscal_year_id, scope, ward_id, subject, body, template_id, linked_darta_id, recipient_id, status, is_fully_approved, dispatch_channel, dispatched_at, dispatched_by, tracking_id, courier_name, is_acknowledged, acknowledged_at, acknowledged_by, acknowledgement_proof_id, delivered_at, delivered_proof_id, superseded_by_id, supersedes_id, created_by, created_at, updated_at, tenant_id, idempotency_key, metadata
`

type MarkChalaniDeliveredParams struct {
	ID               uuid.UUID          `json:"id"`
	DeliveredAt      pgtype.Timestamptz `json:"delivered_at"`
	DeliveredProofID pgtype.UUID        `json:"delivered_proof_id"`
}

func (q *Queries) MarkChalaniDelivered(ctx context.Context, arg MarkChalaniDeliveredParams) (Chalani, error) {
	row := q.db.QueryRow(ctx, markChalaniDelivered, arg.ID, arg.DeliveredAt, arg.DeliveredProofID)
	var i Chalani
	err := row.Scan(
		&i.ID,
		&i.ChalaniNumber,
		&i.FormattedChalaniNumber,
		&i.FiscalYearID,
		&i.Scope,
		&i.WardID,
		&i.Subject,
		&i.Body,
		&i.TemplateID,
		&i.LinkedDartaID,
		&i.RecipientID,
		&i.Status,
		&i.IsFullyApproved,
		&i.DispatchChannel,
		&i.DispatchedAt,
		&i.DispatchedBy,
		&i.TrackingID,
		&i.CourierName,
		&i.IsAcknowledged,
		&i.AcknowledgedAt,
		&i.AcknowledgedBy,
		&i.AcknowledgementProofID,
		&i.DeliveredAt,
		&i.DeliveredProofID,
		&i.SupersededByID,
		&i.SupersedesID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
		&i.IdempotencyKey,
		&i.Metadata,
	)
	return i, err
}

const updateChalaniAcknowledgement = `-- name: UpdateChalaniAcknowledgement :one
UPDATE chalanis
SET 
    is_acknowledged = true,
    acknowledged_at = $2,
    acknowledged_by = $3,
    acknowledgement_proof_id = $4,
    status = 'ACKNOWLEDGED',
    updated_at = NOW()
WHERE id = $1
RETURNING id, chalani_number, formatted_chalani_number, fiscal_year_id, scope, ward_id, subject, body, template_id, linked_darta_id, recipient_id, status, is_fully_approved, dispatch_channel, dispatched_at, dispatched_by, tracking_id, courier_name, is_acknowledged, acknowledged_at, acknowledged_by, acknowledgement_proof_id, delivered_at, delivered_proof_id, superseded_by_id, supersedes_id, created_by, created_at, updated_at, tenant_id, idempotency_key, metadata
`

type UpdateChalaniAcknowledgementParams struct {
	ID                     uuid.UUID          `json:"id"`
	AcknowledgedAt         pgtype.Timestamptz `json:"acknowledged_at"`
	AcknowledgedBy         *string            `json:"acknowledged_by"`
	AcknowledgementProofID pgtype.UUID        `json:"acknowledgement_proof_id"`
}

func (q *Queries) UpdateChalaniAcknowledgement(ctx context.Context, arg UpdateChalaniAcknowledgementParams) (Chalani, error) {
	row := q.db.QueryRow(ctx, updateChalaniAcknowledgement,
		arg.ID,
		arg.AcknowledgedAt,
		arg.AcknowledgedBy,
		arg.AcknowledgementProofID,
	)
	var i Chalani
	err := row.Scan(
		&i.ID,
		&i.ChalaniNumber,
		&i.FormattedChalaniNumber,
		&i.FiscalYearID,
		&i.Scope,
		&i.WardID,
		&i.Subject,
		&i.Body,
		&i.TemplateID,
		&i.LinkedDartaID,
		&i.RecipientID,
		&i.Status,
		&i.IsFullyApproved,
		&i.DispatchChannel,
		&i.DispatchedAt,
		&i.DispatchedBy,
		&i.TrackingID,
		&i.CourierName,
		&i.IsAcknowledged,
		&i.AcknowledgedAt,
		&i.AcknowledgedBy,
		&i.AcknowledgementProofID,
		&i.DeliveredAt,
		&i.DeliveredProofID,
		&i.SupersededByID,
		&i.SupersedesID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
		&i.IdempotencyKey,
		&i.Metadata,
	)
	return i, err
}

const updateChalaniApprovalStatus = `-- name: UpdateChalaniApprovalStatus :one
UPDATE chalanis
SET 
    is_fully_approved = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, chalani_number, formatted_chalani_number, fiscal_year_id, scope, ward_id, subject, body, template_id, linked_darta_id, recipient_id, status, is_fully_approved, dispatch_channel, dispatched_at, dispatched_by, tracking_id, courier_name, is_acknowledged, acknowledged_at, acknowledged_by, acknowledgement_proof_id, delivered_at, delivered_proof_id, superseded_by_id, supersedes_id, created_by, created_at, updated_at, tenant_id, idempotency_key, metadata
`

type UpdateChalaniApprovalStatusParams struct {
	ID              uuid.UUID `json:"id"`
	IsFullyApproved bool      `json:"is_fully_approved"`
}

func (q *Queries) UpdateChalaniApprovalStatus(ctx context.Context, arg UpdateChalaniApprovalStatusParams) (Chalani, error) {
	row := q.db.QueryRow(ctx, updateChalaniApprovalStatus, arg.ID, arg.IsFullyApproved)
	var i Chalani
	err := row.Scan(
		&i.ID,
		&i.ChalaniNumber,
		&i.FormattedChalaniNumber,
		&i.FiscalYearID,
		&i.Scope,
		&i.WardID,
		&i.Subject,
		&i.Body,
		&i.TemplateID,
		&i.LinkedDartaID,
		&i.RecipientID,
		&i.Status,
		&i.IsFullyApproved,
		&i.DispatchChannel,
		&i.DispatchedAt,
		&i.DispatchedBy,
		&i.TrackingID,
		&i.CourierName,
		&i.IsAcknowledged,
		&i.AcknowledgedAt,
		&i.AcknowledgedBy,
		&i.AcknowledgementProofID,
		&i.DeliveredAt,
		&i.DeliveredProofID,
		&i.SupersededByID,
		&i.SupersedesID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
		&i.IdempotencyKey,
		&i.Metadata,
	)
	return i, err
}

const updateChalaniDispatch = `-- name: UpdateChalaniDispatch :one
UPDATE chalanis
SET 
    dispatch_channel = $2,
    dispatched_at = $3,
    dispatched_by = $4,
    tracking_id = $5,
    courier_name = $6,
    status = 'DISPATCHED',
    updated_at = NOW()
WHERE id = $1
RETURNING id, chalani_number, formatted_chalani_number, fiscal_year_id, scope, ward_id, subject, body, template_id, linked_darta_id, recipient_id, status, is_fully_approved, dispatch_channel, dispatched_at, dispatched_by, tracking_id, courier_name, is_acknowledged, acknowledged_at, acknowledged_by, acknowledgement_proof_id, delivered_at, delivered_proof_id, superseded_by_id, supersedes_id, created_by, created_at, updated_at, tenant_id, idempotency_key, metadata
`

type UpdateChalaniDispatchParams struct {
	ID              uuid.UUID          `json:"id"`
	DispatchChannel *string            `json:"dispatch_channel"`
	DispatchedAt    pgtype.Timestamptz `json:"dispatched_at"`
	DispatchedBy    *string            `json:"dispatched_by"`
	TrackingID      *string            `json:"tracking_id"`
	CourierName     *string            `json:"courier_name"`
}

func (q *Queries) UpdateChalaniDispatch(ctx context.Context, arg UpdateChalaniDispatchParams) (Chalani, error) {
	row := q.db.QueryRow(ctx, updateChalaniDispatch,
		arg.ID,
		arg.DispatchChannel,
		arg.DispatchedAt,
		arg.DispatchedBy,
		arg.TrackingID,
		arg.CourierName,
	)
	var i Chalani
	err := row.Scan(
		&i.ID,
		&i.ChalaniNumber,
		&i.FormattedChalaniNumber,
		&i.FiscalYearID,
		&i.Scope,
		&i.WardID,
		&i.Subject,
		&i.Body,
		&i.TemplateID,
		&i.LinkedDartaID,
		&i.RecipientID,
		&i.Status,
		&i.IsFullyApproved,
		&i.DispatchChannel,
		&i.DispatchedAt,
		&i.DispatchedBy,
		&i.TrackingID,
		&i.CourierName,
		&i.IsAcknowledged,
		&i.AcknowledgedAt,
		&i.AcknowledgedBy,
		&i.AcknowledgementProofID,
		&i.DeliveredAt,
		&i.DeliveredProofID,
		&i.SupersededByID,
		&i.SupersedesID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
		&i.IdempotencyKey,
		&i.Metadata,
	)
	return i, err
}

const updateChalaniNumber = `-- name: UpdateChalaniNumber :one
UPDATE chalanis
SET 
    chalani_number = $2,
    formatted_chalani_number = $3,
    updated_at = NOW()
WHERE id = $1
RETURNING id, chalani_number, formatted_chalani_number, fiscal_year_id, scope, ward_id, subject, body, template_id, linked_darta_id, recipient_id, status, is_fully_approved, dispatch_channel, dispatched_at, dispatched_by, tracking_id, courier_name, is_acknowledged, acknowledged_at, acknowledged_by, acknowledgement_proof_id, delivered_at, delivered_proof_id, superseded_by_id, supersedes_id, created_by, created_at, updated_at, tenant_id, idempotency_key, metadata
`

type UpdateChalaniNumberParams struct {
	ID                     uuid.UUID `json:"id"`
	ChalaniNumber          *int32    `json:"chalani_number"`
	FormattedChalaniNumber *string   `json:"formatted_chalani_number"`
}

func (q *Queries) UpdateChalaniNumber(ctx context.Context, arg UpdateChalaniNumberParams) (Chalani, error) {
	row := q.db.QueryRow(ctx, updateChalaniNumber, arg.ID, arg.ChalaniNumber, arg.FormattedChalaniNumber)
	var i Chalani
	err := row.Scan(
		&i.ID,
		&i.ChalaniNumber,
		&i.FormattedChalaniNumber,
		&i.FiscalYearID,
		&i.Scope,
		&i.WardID,
		&i.Subject,
		&i.Body,
		&i.TemplateID,
		&i.LinkedDartaID,
		&i.RecipientID,
		&i.Status,
		&i.IsFullyApproved,
		&i.DispatchChannel,
		&i.DispatchedAt,
		&i.DispatchedBy,
		&i.TrackingID,
		&i.CourierName,
		&i.IsAcknowledged,
		&i.AcknowledgedAt,
		&i.AcknowledgedBy,
		&i.AcknowledgementProofID,
		&i.DeliveredAt,
		&i.DeliveredProofID,
		&i.SupersededByID,
		&i.SupersedesID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
		&i.IdempotencyKey,
		&i.Metadata,
	)
	return i, err
}

const updateChalaniStatus = `-- name: UpdateChalaniStatus :one
UPDATE chalanis
SET status = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, chalani_number, formatted_chalani_number, fiscal_year_id, scope, ward_id, subject, body, template_id, linked_darta_id, recipient_id, status, is_fully_approved, dispatch_channel, dispatched_at, dispatched_by, tracking_id, courier_name, is_acknowledged, acknowledged_at, acknowledged_by, acknowledgement_proof_id, delivered_at, delivered_proof_id, superseded_by_id, supersedes_id, created_by, created_at, updated_at, tenant_id, idempotency_key, metadata
`

type UpdateChalaniStatusParams struct {
	ID     uuid.UUID `json:"id"`
	Status string    `json:"status"`
}

func (q *Queries) UpdateChalaniStatus(ctx context.Context, arg UpdateChalaniStatusParams) (Chalani, error) {
	row := q.db.QueryRow(ctx, updateChalaniStatus, arg.ID, arg.Status)
	var i Chalani
	err := row.Scan(
		&i.ID,
		&i.ChalaniNumber,
		&i.FormattedChalaniNumber,
		&i.FiscalYearID,
		&i.Scope,
		&i.WardID,
		&i.Subject,
		&i.Body,
		&i.TemplateID,
		&i.LinkedDartaID,
		&i.RecipientID,
		&i.Status,
		&i.IsFullyApproved,
		&i.DispatchChannel,
		&i.DispatchedAt,
		&i.DispatchedBy,
		&i.TrackingID,
		&i.CourierName,
		&i.IsAcknowledged,
		&i.AcknowledgedAt,
		&i.AcknowledgedBy,
		&i.AcknowledgementProofID,
		&i.DeliveredAt,
		&i.DeliveredProofID,
		&i.SupersededByID,
		&i.SupersedesID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
		&i.IdempotencyKey,
		&i.Metadata,
	)
	return i, err
}

const voidChalani = `-- name: VoidChalani :one
UPDATE chalanis
SET 
    status = 'VOIDED',
    updated_at = NOW()
WHERE id = $1
RETURNING id, chalani_number, formatted_chalani_number, fiscal_year_id, scope, ward_id, subject, body, template_id, linked_darta_id, recipient_id, status, is_fully_approved, dispatch_channel, dispatched_at, dispatched_by, tracking_id, courier_name, is_acknowledged, acknowledged_at, acknowledged_by, acknowledgement_proof_id, delivered_at, delivered_proof_id, superseded_by_id, supersedes_id, created_by, created_at, updated_at, tenant_id, idempotency_key, metadata
`

func (q *Queries) VoidChalani(ctx context.Context, id uuid.UUID) (Chalani, error) {
	row := q.db.QueryRow(ctx, voidChalani, id)
	var i Chalani
	err := row.Scan(
		&i.ID,
		&i.ChalaniNumber,
		&i.FormattedChalaniNumber,
		&i.FiscalYearID,
		&i.Scope,
		&i.WardID,
		&i.Subject,
		&i.Body,
		&i.TemplateID,
		&i.LinkedDartaID,
		&i.RecipientID,
		&i.Status,
		&i.IsFullyApproved,
		&i.DispatchChannel,
		&i.DispatchedAt,
		&i.DispatchedBy,
		&i.TrackingID,
		&i.CourierName,
		&i.IsAcknowledged,
		&i.AcknowledgedAt,
		&i.AcknowledgedBy,
		&i.AcknowledgementProofID,
		&i.DeliveredAt,
		&i.DeliveredProofID,
		&i.SupersededByID,
		&i.SupersedesID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
		&i.IdempotencyKey,
		&i.Metadata,
	)
	return i, err
}
