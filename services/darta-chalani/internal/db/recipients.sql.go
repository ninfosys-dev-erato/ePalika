// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: recipients.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const countRecipients = `-- name: CountRecipients :one
SELECT COUNT(*) FROM recipients
WHERE
    ($1::VARCHAR IS NULL OR type = $1)
    AND ($2::TEXT IS NULL OR 
         name ILIKE '%' || $2 || '%' OR
         organization ILIKE '%' || $2 || '%')
`

type CountRecipientsParams struct {
	Type   *string `json:"type"`
	Search *string `json:"search"`
}

func (q *Queries) CountRecipients(ctx context.Context, arg CountRecipientsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countRecipients, arg.Type, arg.Search)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createRecipient = `-- name: CreateRecipient :one

INSERT INTO recipients (
    type,
    name,
    organization,
    email,
    phone,
    address
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, type, name, organization, email, phone, address, created_at, updated_at
`

type CreateRecipientParams struct {
	Type         string  `json:"type"`
	Name         string  `json:"name"`
	Organization *string `json:"organization"`
	Email        *string `json:"email"`
	Phone        *string `json:"phone"`
	Address      string  `json:"address"`
}

// ============================================================================
// RECIPIENTS - People/Organizations receiving chalani
// ============================================================================
func (q *Queries) CreateRecipient(ctx context.Context, arg CreateRecipientParams) (Recipient, error) {
	row := q.db.QueryRow(ctx, createRecipient,
		arg.Type,
		arg.Name,
		arg.Organization,
		arg.Email,
		arg.Phone,
		arg.Address,
	)
	var i Recipient
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Name,
		&i.Organization,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteRecipient = `-- name: DeleteRecipient :exec
DELETE FROM recipients WHERE id = $1
`

func (q *Queries) DeleteRecipient(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteRecipient, id)
	return err
}

const findRecipientByContact = `-- name: FindRecipientByContact :one
SELECT id, type, name, organization, email, phone, address, created_at, updated_at FROM recipients
WHERE email = $1 OR phone = $2
ORDER BY created_at DESC
LIMIT 1
`

type FindRecipientByContactParams struct {
	Email *string `json:"email"`
	Phone *string `json:"phone"`
}

func (q *Queries) FindRecipientByContact(ctx context.Context, arg FindRecipientByContactParams) (Recipient, error) {
	row := q.db.QueryRow(ctx, findRecipientByContact, arg.Email, arg.Phone)
	var i Recipient
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Name,
		&i.Organization,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRecipient = `-- name: GetRecipient :one
SELECT id, type, name, organization, email, phone, address, created_at, updated_at FROM recipients
WHERE id = $1
`

func (q *Queries) GetRecipient(ctx context.Context, id uuid.UUID) (Recipient, error) {
	row := q.db.QueryRow(ctx, getRecipient, id)
	var i Recipient
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Name,
		&i.Organization,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listRecipients = `-- name: ListRecipients :many
SELECT id, type, name, organization, email, phone, address, created_at, updated_at FROM recipients
WHERE
    ($1::VARCHAR IS NULL OR type = $1)
    AND ($2::TEXT IS NULL OR 
         name ILIKE '%' || $2 || '%' OR
         organization ILIKE '%' || $2 || '%')
ORDER BY created_at DESC
LIMIT $4
OFFSET $3
`

type ListRecipientsParams struct {
	Type   *string `json:"type"`
	Search *string `json:"search"`
	Offset int32   `json:"offset"`
	Limit  int32   `json:"limit"`
}

func (q *Queries) ListRecipients(ctx context.Context, arg ListRecipientsParams) ([]Recipient, error) {
	rows, err := q.db.Query(ctx, listRecipients,
		arg.Type,
		arg.Search,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Recipient
	for rows.Next() {
		var i Recipient
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Name,
			&i.Organization,
			&i.Email,
			&i.Phone,
			&i.Address,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRecipient = `-- name: UpdateRecipient :one
UPDATE recipients
SET
    type = COALESCE($2, type),
    name = COALESCE($3, name),
    organization = COALESCE($4, organization),
    email = COALESCE($5, email),
    phone = COALESCE($6, phone),
    address = COALESCE($7, address)
WHERE id = $1
RETURNING id, type, name, organization, email, phone, address, created_at, updated_at
`

type UpdateRecipientParams struct {
	ID           uuid.UUID `json:"id"`
	Type         *string   `json:"type"`
	Name         *string   `json:"name"`
	Organization *string   `json:"organization"`
	Email        *string   `json:"email"`
	Phone        *string   `json:"phone"`
	Address      *string   `json:"address"`
}

func (q *Queries) UpdateRecipient(ctx context.Context, arg UpdateRecipientParams) (Recipient, error) {
	row := q.db.QueryRow(ctx, updateRecipient,
		arg.ID,
		arg.Type,
		arg.Name,
		arg.Organization,
		arg.Email,
		arg.Phone,
		arg.Address,
	)
	var i Recipient
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Name,
		&i.Organization,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
