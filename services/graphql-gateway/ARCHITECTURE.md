# GraphQL Gateway Architecture

## Overview

The GraphQL Gateway is the primary API entry point for the ePalika system, providing a unified GraphQL interface to multiple backend gRPC microservices.

## Request Flow

```
Client Request
    ↓
Oathkeeper (Port 4455)
    ↓ [JWT Authentication]
    ↓ [PDP Authorization]
    ↓ [Header Mutation]
GraphQL Gateway (Port 8000)
    ↓ [GraphQL Parsing]
    ↓ [Resolver Execution]
Darta-Chalani gRPC Service (Port 9000)
    ↓ [gRPC Interceptor - Context Extraction]
    ↓ [Domain Service - Business Logic]
    ↓ [Repository Layer - sqlc]
PostgreSQL/YugabyteDB
```

## Components

### 1. Oathkeeper (API Gateway & Auth Proxy)

**Location**: `policies/oathkeeper/`

**Responsibilities**:
- JWT token validation via Keycloak
- Policy Decision Point (PDP) authorization
- Header injection for downstream services
- Request routing to appropriate upstreams

**Key Headers Injected**:
- `X-User-ID`: Keycloak subject/user ID
- `X-Tenant`: Multi-tenant organization ID
- `X-Roles`: Comma-separated user roles
- `X-Request-ID`: Unique request identifier (UUID)
- `X-User-Name`: User's full name
- `Traceparent`: W3C trace context for distributed tracing

**Access Rules** (`policies/oathkeeper/base/graphql_gateway.json`):

1. **GraphQL Query Endpoint** (`/query`)
   - Methods: `POST`, `OPTIONS`
   - Authenticator: JWT (Keycloak)
   - Authorizer: PDP remote_json
   - Upstream: `http://graphql-gateway:8000`

2. **GraphQL Playground** (`/playground`) - Development Only
   - Methods: `GET`
   - Authenticator: noop (no auth)
   - Authorizer: allow
   - Upstream: `http://graphql-gateway:8000`

3. **Health Check** (`/health`)
   - Methods: `GET`
   - Authenticator: noop
   - Authorizer: allow
   - Upstream: `http://graphql-gateway:8000`

### 2. PDP (Policy Decision Point)

**Service**: `pdp:8080`

**Authorization Request Payload**:
```json
{
  "subject": "user-uuid",
  "resource": "graphql:query",
  "action": "execute",
  "claims": {
    "tenant": "palika_bagmati",
    "roles": ["darta_clerk", "admin"]
  },
  "context": {
    "time": "2025-10-05T14:30:00Z",
    "ip": "192.168.1.100"
  }
}
```

**Response**:
- HTTP 200: Authorization granted
- HTTP 403: Authorization denied
- Headers: `X-Authz-Decision`, `X-Authz-Reason`

### 3. GraphQL Gateway

**Location**: `services/graphql-gateway/`

**Port**: 8000

**Endpoints**:
- `GET /`: GraphQL Playground (HTML interface)
- `POST /query`: GraphQL API endpoint
- `GET /health`: Health check

**Schema** (`schema/schema.graphql`):

**Queries**:
- `health`: Service health status
- `darta(id: ID!)`: Get single Darta by ID
- `dartas(filter: DartaFilterInput, pagination: PaginationInput)`: List Dartas with filtering
- `myDartas(status: DartaStatus, pagination: PaginationInput)`: Current user's assigned Dartas
- `dartaStats(scope: Scope, fiscalYearId: String, wardId: String)`: Statistics dashboard

**Mutations**:
- `createDarta(input: CreateDartaInput!)`: Create new Darta entry
- `submitDartaForReview(dartaId: ID!)`: Submit draft for review
- `classifyDarta(dartaId: ID!, classificationCode: String!)`: Classify Darta
- `reserveDartaNumber(dartaId: ID!)`: Reserve sequential number
- `finalizeDartaRegistration(dartaId: ID!)`: Finalize registration
- `routeDarta(input: RouteDartaInput!)`: Route to department/user
- `closeDarta(dartaId: ID!)`: Close completed Darta
- `voidDarta(dartaId: ID!, reason: String!)`: Void/cancel Darta

**Resolver Implementation** (`graph/schema.resolvers.go`):

Each resolver:
1. Receives GraphQL input
2. Converts to Proto message (via `converters.go`)
3. Calls gRPC service client
4. Converts Proto response back to GraphQL model
5. Returns to client

**Client Initialization** (`internal/clients/`):
- `DartaClient`: gRPC connection to darta-chalani service
- `PDPClient`: gRPC connection to PDP service (future use)

### 4. Darta-Chalani gRPC Service

**Location**: `services/darta-chalani/`

**Port**: 9000 (gRPC)

**Proto Definitions** (`proto/darta/v1/`):
- `common.proto`: Shared types, enums, pagination
- `darta.proto`: 27 RPC methods for incoming correspondence
- `chalani.proto`: 28 RPC methods for outgoing correspondence

**gRPC Interceptors** (`internal/grpc/interceptors.go`):

Extracts headers from gRPC metadata:
```go
X-User-ID → UserContext.UserID
X-Tenant → UserContext.TenantID
X-Roles → UserContext.Roles
X-Request-ID → UserContext.RequestID
```

**Domain Services** (`internal/domain/`):

Business logic layer with:
- State machine validation (19 Darta states, 16 Chalani states)
- Sequential number generation (per fiscal year/scope/ward)
- Idempotency key checking
- Multi-tenant isolation
- Audit trail creation

**Repository Layer** (`internal/db/`):

Generated by sqlc from 90+ SQL queries:
- Type-safe database operations
- Null handling with pointers
- JSONB support for metadata
- Full-text search on subjects

**Database Schema** (`internal/dbutil/migrations/00001_initial_schema.sql`):

Tables:
- `dartas`: Incoming correspondence records
- `chalanis`: Outgoing correspondence records
- `applicants`: Darta applicant information
- `recipients`: Chalani recipient information
- `attachments`: File attachments
- `darta_attachments`: Darta-attachment relations
- `chalani_attachments`: Chalani-attachment relations
- `darta_routing`: Routing history
- `chalani_approvals`: Approval workflow
- `audit_trail`: Change history
- `templates`: Letter templates
- `dispatch_tracking`: Delivery tracking

## Data Flow Example

### Create Darta Request

**1. Client Request**:
```graphql
mutation CreateDarta {
  createDarta(input: {
    fiscalYearID: "fy-2081-82"
    scope: MUNICIPALITY
    subject: "Budget Approval Request"
    applicant: {
      type: ORGANIZATION
      fullName: "ABC Corporation"
      email: "abc@example.com"
      phone: "9841234567"
    }
    intakeChannel: EDARTA_PORTAL
    receivedDate: "2025-10-05T10:00:00Z"
    priority: HIGH
  }) {
    id
    dartaNumber
    formattedDartaNumber
    status
  }
}
```

**2. Oathkeeper Processing**:
- Validates JWT token with Keycloak
- Calls PDP: `POST http://pdp:8080/authorize`
  ```json
  {
    "subject": "user-123",
    "resource": "graphql:query",
    "action": "execute",
    "claims": {"tenant": "palika_bagmati", "roles": ["darta_clerk"]}
  }
  ```
- PDP returns 200 OK
- Injects headers and forwards to GraphQL Gateway

**3. GraphQL Gateway**:
- Parses GraphQL query
- Calls `CreateDarta` resolver
- Converts input to Proto:
  ```go
  req := &dartav1.CreateDartaRequest{
    Input: &dartav1.CreateDartaInput{
      FiscalYearId: "fy-2081-82",
      Scope: dartav1.Scope_SCOPE_MUNICIPALITY,
      Subject: "Budget Approval Request",
      // ... converted fields
    },
  }
  ```
- Calls gRPC: `r.DartaClient.CreateDarta(ctx, req)`

**4. Darta-Chalani gRPC Server**:
- Interceptor extracts user context from headers
- Validates state transitions
- Checks idempotency key (if provided)
- Creates applicant record
- Creates darta record with status=DRAFT
- Generates audit trail entry
- Returns Proto response

**5. Response Flow**:
- gRPC → GraphQL converter (`protoToDarta`)
- GraphQL response to client:
  ```json
  {
    "data": {
      "createDarta": {
        "id": "uuid-here",
        "dartaNumber": null,
        "formattedDartaNumber": null,
        "status": "DRAFT"
      }
    }
  }
  ```

## Security Model

### Authentication (Oathkeeper + Keycloak)

1. Client obtains JWT from Keycloak OAuth2/OIDC flow
2. Client sends JWT in `Authorization: Bearer <token>` header
3. Oathkeeper validates JWT:
   - Signature verification via JWKS
   - Issuer validation
   - Expiry check
   - Required scopes check
4. Oathkeeper extracts claims (subject, tenant, roles, email, name)

### Authorization (PDP)

1. Oathkeeper constructs authorization request
2. PDP evaluates policies:
   - Role-based access control (RBAC)
   - Attribute-based access control (ABAC)
   - Resource ownership checks
   - Tenant isolation enforcement
3. PDP returns allow/deny decision
4. Oathkeeper forwards or blocks request

### Multi-Tenancy

Enforced at every layer:

**Database**:
```sql
WHERE tenant_id = $1  -- From user context
```

**Domain Services**:
```go
userCtx := GetUserContext(ctx)
// All queries filtered by userCtx.TenantID
```

**GraphQL Resolvers**:
```go
// Context automatically propagated via gRPC metadata
```

## State Machines

### Darta States (19 total)

```
DRAFT → PENDING_REVIEW → CLASSIFICATION → NUMBERED → FINALIZED
                                              ↓
                                          ROUTED
                                              ↓
                                      UNDER_PROCESSING
                                              ↓
                                          RESOLVED
                                              ↓
                                          CLOSED
```

Also: PENDING_APPROVAL, APPROVED, REJECTED, ON_HOLD, ESCALATED, TRANSFERRED, ARCHIVED, VOIDED, RETURNED_FOR_CLARIFICATION, CANCELLED, EXPIRED, WITHDRAWN

### Chalani States (16 total)

```
DRAFT → PENDING_APPROVAL → APPROVED → DISPATCHED → DELIVERED
```

Also: REJECTED, RECALLED, ON_HOLD, PENDING_SIGNATURE, SIGNED, CANCELLED, FAILED_DELIVERY, IN_TRANSIT, ARCHIVED, VOIDED

## Configuration

### Environment Variables

**GraphQL Gateway**:
```env
PORT=8000
DARTA_GRPC_ADDR=darta-chalani:9000
PDP_GRPC_ADDR=pdp:8080
LOG_LEVEL=info
```

**Darta-Chalani Service**:
```env
GRPC_PORT=9000
DATABASE_DSN=postgresql://user:pass@db:5432/epalika
LOG_LEVEL=info
```

**Oathkeeper**:
```env
SERVE_PROXY_PORT=4455
SERVE_API_PORT=4456
ACCESS_RULES_REPOSITORIES=file:///policies/oathkeeper/base
```

## Development

### Running Services

1. **Start infrastructure**:
   ```bash
   docker-compose up -d keycloak postgres pdp
   ```

2. **Run migrations**:
   ```bash
   cd services/darta-chalani
   goose -dir internal/dbutil/migrations postgres "$DATABASE_DSN" up
   ```

3. **Start Darta-Chalani service**:
   ```bash
   cd services/darta-chalani
   go run cmd/dartasvc/main.go
   ```

4. **Start GraphQL Gateway**:
   ```bash
   cd services/graphql-gateway
   go run cmd/gateways/main.go
   ```

5. **Start Oathkeeper**:
   ```bash
   docker-compose up -d oathkeeper
   ```

6. **Access Playground**:
   ```
   http://localhost:4455/playground
   ```

### Testing Flow

1. **Obtain JWT token**:
   ```bash
   curl -X POST http://localhost:8083/realms/palika/protocol/openid-connect/token \
     -d "client_id=palika-api" \
     -d "client_secret=secret" \
     -d "grant_type=password" \
     -d "username=clerk@example.com" \
     -d "password=password"
   ```

2. **Call GraphQL API**:
   ```bash
   curl -X POST http://localhost:4455/query \
     -H "Authorization: Bearer $TOKEN" \
     -H "Content-Type: application/json" \
     -d '{"query": "{ health { status service } }"}'
   ```

## Observability

### Distributed Tracing

W3C Trace Context propagation:
```
Client Request ID
    ↓ (X-Request-ID)
Oathkeeper (Traceparent generation)
    ↓ (Traceparent header)
GraphQL Gateway (context propagation)
    ↓ (gRPC metadata)
Darta-Chalani Service (trace extraction)
    ↓ (audit trail)
Database (stored in audit_trail.notes)
```

### Logging

Structured JSON logging at each layer:
- Request ID correlation
- User/tenant context
- Error details
- Performance metrics

### Audit Trail

All state changes recorded:
```sql
INSERT INTO audit_trail (
  entity_type, entity_id, action, performed_by,
  changes, ip_address, user_agent
) VALUES (
  'DARTA', 'uuid', 'STATUS_CHANGED', 'user-123',
  '{"before": "DRAFT", "after": "PENDING_REVIEW"}',
  '192.168.1.100', 'Mozilla/5.0...'
);
```

## Performance Considerations

1. **Connection Pooling**: pgxpool with max 25 connections
2. **gRPC Interceptors**: Minimal overhead for context extraction
3. **Database Indexes**: All foreign keys, search columns indexed
4. **Pagination**: Cursor-based and offset-based support
5. **Caching**: JWT validation cached for 60s in Oathkeeper

## Security Considerations

1. **No Direct Database Access**: All traffic through GraphQL → gRPC
2. **Header Validation**: Only Oathkeeper can set X-User-ID, X-Tenant headers
3. **SQL Injection**: Prevented by sqlc parameter binding
4. **CORS**: Configured in GraphQL Gateway
5. **Rate Limiting**: TODO - Add in Oathkeeper
6. **Request Size Limits**: Configured in gRPC and GraphQL servers
