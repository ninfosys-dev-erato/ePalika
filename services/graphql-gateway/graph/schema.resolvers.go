package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.80

import (
	"context"

	dartav1 "git.ninjainfosys.com/ePalika/proto/gen/darta/v1"
	"git.ninjainfosys.com/ePalika/graphql-gateway/graph/model"
	"google.golang.org/protobuf/types/known/timestamppb"
)

// CreateDarta is the resolver for the createDarta field.
func (r *mutationResolver) CreateDarta(ctx context.Context, input model.CreateDartaInput) (*model.Darta, error) {
	// Convert GraphQL input to proto
	req := &dartav1.CreateDartaRequest{
		Input: &dartav1.CreateDartaInput{
			FiscalYearId: input.FiscalYearID,
			Scope:        scopeToProto(input.Scope),
			WardId:       stringPtrValue(input.WardID),
			Subject:      input.Subject,
			Applicant: &dartav1.ApplicantInput{
				Type:         applicantTypeToProto(input.Applicant.Type),
				FullName:     input.Applicant.FullName,
				Organization: stringPtrValue(input.Applicant.Organization),
				Email:        stringPtrValue(input.Applicant.Email),
				Phone:        stringPtrValue(input.Applicant.Phone),
				Address:      stringPtrValue(input.Applicant.Address),
				IdentificationNumber: stringPtrValue(input.Applicant.IdentificationNumber),
			},
			IntakeChannel:     intakeChannelToProto(input.IntakeChannel),
			ReceivedDate:      parseTimestamp(input.ReceivedDate),
			PrimaryDocumentId: input.PrimaryDocumentID,
			AnnexIds:          stringSliceValue(input.AnnexIds),
			Priority:          priorityToProto(input.Priority),
			IdempotencyKey:    input.IdempotencyKey,
		},
	}

	// Call gRPC service
	resp, err := r.DartaClient.CreateDarta(ctx, req)
	if err != nil {
		return nil, err
	}

	// Convert proto response to GraphQL
	return protoToDarta(resp.Darta), nil
}

// SubmitDartaForReview is the resolver for the submitDartaForReview field.
func (r *mutationResolver) SubmitDartaForReview(ctx context.Context, dartaID string) (*model.Darta, error) {
	req := &dartav1.SubmitDartaForReviewRequest{
		DartaId: dartaID,
	}

	resp, err := r.DartaClient.SubmitDartaForReview(ctx, req)
	if err != nil {
		return nil, err
	}

	return protoToDarta(resp.Darta), nil
}

// ClassifyDarta is the resolver for the classifyDarta field.
func (r *mutationResolver) ClassifyDarta(ctx context.Context, dartaID string, classificationCode string) (*model.Darta, error) {
	req := &dartav1.ClassifyDartaRequest{
		DartaId:            dartaID,
		ClassificationCode: classificationCode,
	}

	resp, err := r.DartaClient.ClassifyDarta(ctx, req)
	if err != nil {
		return nil, err
	}

	return protoToDarta(resp.Darta), nil
}

// ReserveDartaNumber is the resolver for the reserveDartaNumber field.
func (r *mutationResolver) ReserveDartaNumber(ctx context.Context, dartaID string) (*model.Darta, error) {
	req := &dartav1.ReserveDartaNumberRequest{
		DartaId: dartaID,
	}

	resp, err := r.DartaClient.ReserveDartaNumber(ctx, req)
	if err != nil {
		return nil, err
	}

	return protoToDarta(resp.Darta), nil
}

// FinalizeDartaRegistration is the resolver for the finalizeDartaRegistration field.
func (r *mutationResolver) FinalizeDartaRegistration(ctx context.Context, dartaID string) (*model.Darta, error) {
	req := &dartav1.FinalizeDartaRegistrationRequest{
		DartaId: dartaID,
	}

	resp, err := r.DartaClient.FinalizeDartaRegistration(ctx, req)
	if err != nil {
		return nil, err
	}

	return protoToDarta(resp.Darta), nil
}

// RouteDarta is the resolver for the routeDarta field.
func (r *mutationResolver) RouteDarta(ctx context.Context, input model.RouteDartaInput) (*model.Darta, error) {
	req := &dartav1.RouteDartaRequest{
		Input: &dartav1.RouteDartaInput{
			DartaId:              input.DartaID,
			OrganizationalUnitId: stringPtrValue(input.OrganizationalUnitID),
			AssigneeId:           stringPtrValue(input.AssigneeID),
			Priority:             priorityPtrToProto(input.Priority),
			SlaHours:             int32PtrValue(input.SlaHours),
			Notes:                stringPtrValue(input.Notes),
		},
	}

	resp, err := r.DartaClient.RouteDarta(ctx, req)
	if err != nil {
		return nil, err
	}

	return protoToDarta(resp.Darta), nil
}

// CloseDarta is the resolver for the closeDarta field.
func (r *mutationResolver) CloseDarta(ctx context.Context, dartaID string) (*model.Darta, error) {
	req := &dartav1.CloseDartaRequest{
		DartaId: dartaID,
	}

	resp, err := r.DartaClient.CloseDarta(ctx, req)
	if err != nil {
		return nil, err
	}

	return protoToDarta(resp.Darta), nil
}

// VoidDarta is the resolver for the voidDarta field.
func (r *mutationResolver) VoidDarta(ctx context.Context, dartaID string, reason string) (*model.Darta, error) {
	req := &dartav1.VoidDartaRequest{
		DartaId: dartaID,
		Reason:  reason,
	}

	resp, err := r.DartaClient.VoidDarta(ctx, req)
	if err != nil {
		return nil, err
	}

	return protoToDarta(resp.Darta), nil
}

// Health is the resolver for the health field.
func (r *queryResolver) Health(ctx context.Context) (*model.HealthStatus, error) {
	req := &dartav1.HealthCheckRequest{}

	resp, err := r.DartaClient.HealthCheck(ctx, req)
	if err != nil {
		return nil, err
	}

	return &model.HealthStatus{
		Status:    resp.Status,
		Service:   resp.Service,
		Timestamp: resp.Timestamp.AsTime().Format("2006-01-02T15:04:05Z07:00"),
	}, nil
}

// Darta is the resolver for the darta field.
func (r *queryResolver) Darta(ctx context.Context, id string) (*model.Darta, error) {
	req := &dartav1.GetDartaRequest{
		Id: id,
	}

	resp, err := r.DartaClient.GetDarta(ctx, req)
	if err != nil {
		return nil, err
	}

	return protoToDarta(resp.Darta), nil
}

// Dartas is the resolver for the dartas field.
func (r *queryResolver) Dartas(ctx context.Context, filter *model.DartaFilterInput, pagination *model.PaginationInput) (*model.DartaConnection, error) {
	req := &dartav1.ListDartasRequest{
		Filter:     buildDartaFilter(filter),
		Pagination: buildPagination(pagination),
	}

	resp, err := r.DartaClient.ListDartas(ctx, req)
	if err != nil {
		return nil, err
	}

	// Convert response
	edges := make([]*model.DartaEdge, len(resp.Connection.Edges))
	for i, edge := range resp.Connection.Edges {
		edges[i] = &model.DartaEdge{
			Cursor: edge.Cursor,
			Node:   protoToDarta(edge.Node),
		}
	}

	return &model.DartaConnection{
		Edges: edges,
		PageInfo: &model.PageInfo{
			HasNextPage:     resp.Connection.PageInfo.HasNextPage,
			HasPreviousPage: resp.Connection.PageInfo.HasPreviousPage,
			TotalCount:      int(resp.Connection.PageInfo.TotalCount),
		},
	}, nil
}

// MyDartas is the resolver for the myDartas field.
func (r *queryResolver) MyDartas(ctx context.Context, status *model.DartaStatus, pagination *model.PaginationInput) (*model.DartaConnection, error) {
	req := &dartav1.GetMyDartasRequest{
		Status:     dartaStatusPtrToProto(status),
		Pagination: buildPagination(pagination),
	}

	resp, err := r.DartaClient.GetMyDartas(ctx, req)
	if err != nil {
		return nil, err
	}

	edges := make([]*model.DartaEdge, len(resp.Connection.Edges))
	for i, edge := range resp.Connection.Edges {
		edges[i] = &model.DartaEdge{
			Cursor: edge.Cursor,
			Node:   protoToDarta(edge.Node),
		}
	}

	return &model.DartaConnection{
		Edges: edges,
		PageInfo: &model.PageInfo{
			HasNextPage:     resp.Connection.PageInfo.HasNextPage,
			HasPreviousPage: resp.Connection.PageInfo.HasPreviousPage,
			TotalCount:      int(resp.Connection.PageInfo.TotalCount),
		},
	}, nil
}

// DartaStats is the resolver for the dartaStats field.
func (r *queryResolver) DartaStats(ctx context.Context, scope *model.Scope, fiscalYearID *string, wardID *string) (*model.DartaStats, error) {
	req := &dartav1.GetDartaStatsRequest{
		Scope:        scopePtrToProto(scope),
		FiscalYearId: stringPtrValue(fiscalYearID),
		WardId:       stringPtrValue(wardID),
	}

	resp, err := r.DartaClient.GetDartaStats(ctx, req)
	if err != nil {
		return nil, err
	}

	byStatus := make([]*model.DartaStatusCount, len(resp.Stats.ByStatus))
	for i, sc := range resp.Stats.ByStatus {
		byStatus[i] = &model.DartaStatusCount{
			Status: protoToDartaStatus(sc.Status),
			Count:  int(sc.Count),
		}
	}

	byChannel := make([]*model.ChannelCount, len(resp.Stats.ByChannel))
	for i, cc := range resp.Stats.ByChannel {
		byChannel[i] = &model.ChannelCount{
			Channel: protoToIntakeChannel(cc.Channel),
			Count:   int(cc.Count),
		}
	}

	return &model.DartaStats{
		Total:        int(resp.Stats.Total),
		ByStatus:     byStatus,
		ByChannel:    byChannel,
		OverdueCount: int(resp.Stats.OverdueCount),
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// Helper functions for conversion
func protoToDarta(d *dartav1.Darta) *model.Darta {
	if d == nil {
		return nil
	}

	darta := &model.Darta{
		ID:             d.Id,
		FiscalYearID:   d.FiscalYear.Id,
		Scope:          protoToScope(d.Scope),
		Subject:        d.Subject,
		IntakeChannel:  protoToIntakeChannel(d.IntakeChannel),
		ReceivedDate:   d.ReceivedDate.AsTime().Format("2006-01-02T15:04:05Z07:00"),
		EntryDate:      d.EntryDate.AsTime().Format("2006-01-02T15:04:05Z07:00"),
		Status:         protoToDartaStatus(d.Status),
		Priority:       protoToPriority(d.Priority),
		CreatedBy:      d.CreatedBy.Id,
		CreatedAt:      d.CreatedAt.AsTime().Format("2006-01-02T15:04:05Z07:00"),
		UpdatedAt:      d.UpdatedAt.AsTime().Format("2006-01-02T15:04:05Z07:00"),
		TenantID:       d.TenantID,
	}

	if d.DartaNumber > 0 {
		num := int(d.DartaNumber)
		darta.DartaNumber = &num
	}
	if d.FormattedDartaNumber != "" {
		darta.FormattedDartaNumber = &d.FormattedDartaNumber
	}
	if d.Ward != nil {
		darta.WardID = &d.Ward.Id
	}
	if d.Applicant != nil {
		darta.Applicant = &model.Applicant{
			ID:       d.Applicant.Id,
			Type:     protoToApplicantType(d.Applicant.Type),
			FullName: d.Applicant.FullName,
		}
		if d.Applicant.Organization != "" {
			darta.Applicant.Organization = &d.Applicant.Organization
		}
	}

	return darta
}

func parseTimestamp(s string) *timestamppb.Timestamp {
	// For now, return current timestamp
	// TODO: Parse the string properly
	return timestamppb.Now()
}

func stringPtrValue(s *string) string {
	if s == nil {
		return ""
	}
	return *s
}

func stringSliceValue(s []string) []string {
	if s == nil {
		return []string{}
	}
	return s
}

func int32PtrValue(i *int) int32 {
	if i == nil {
		return 0
	}
	return int32(*i)
}

func buildDartaFilter(filter *model.DartaFilterInput) *dartav1.DartaFilterInput {
	if filter == nil {
		return &dartav1.DartaFilterInput{}
	}

	return &dartav1.DartaFilterInput{
		FiscalYearId:         stringPtrValue(filter.FiscalYearID),
		Scope:                scopePtrToProto(filter.Scope),
		WardId:               stringPtrValue(filter.WardID),
		Status:               dartaStatusPtrToProto(filter.Status),
		Priority:             priorityPtrToProto(filter.Priority),
		OrganizationalUnitId: stringPtrValue(filter.OrganizationalUnitID),
		AssigneeId:           stringPtrValue(filter.AssigneeID),
		IntakeChannel:        intakeChannelPtrToProto(filter.IntakeChannel),
		Search:               stringPtrValue(filter.Search),
	}
}

func buildPagination(p *model.PaginationInput) *dartav1.PaginationInput {
	if p == nil {
		return &dartav1.PaginationInput{
			Limit: 10,
		}
	}

	return &dartav1.PaginationInput{
		Limit:  int32PtrValue(p.Limit),
		Offset: int32PtrValue(p.Offset),
	}
}
