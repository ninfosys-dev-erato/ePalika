package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.80

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"git.ninjainfosys.com/ePalika/graphql-gateway/graph/model"
)

// PdpHealth is the resolver for the pdpHealth field.
func (r *queryResolver) PdpHealth(ctx context.Context) (*model.HealthStatus, error) {
	endpoint, err := joinEndpoint(r.PDPURL, "healthz")
	if err != nil {
		return nil, fmt.Errorf("build pdp health endpoint: %w", err)
	}

	body, statusCode, err := r.doJSONRequest(ctx, http.MethodGet, endpoint, nil)
	if err != nil {
		return &model.HealthStatus{Status: "unhealthy", Service: "pdp"}, nil
	}

	timestamp := time.Now().UTC().Format(time.RFC3339)
	if statusCode >= 400 {
		return &model.HealthStatus{
			Status:    "unhealthy",
			Service:   "pdp",
			Timestamp: &timestamp,
		}, nil
	}

	var payload struct {
		Status    string  `json:"status"`
		Service   string  `json:"service"`
		Timestamp *string `json:"timestamp"`
	}
	if err := json.Unmarshal(body, &payload); err != nil {
		return &model.HealthStatus{Status: "healthy", Service: "pdp", Timestamp: &timestamp}, nil
	}

	if payload.Status == "" {
		payload.Status = "healthy"
	}
	if payload.Service == "" {
		payload.Service = "pdp"
	}
	if payload.Timestamp == nil {
		payload.Timestamp = &timestamp
	}

	return &model.HealthStatus{
		Status:    payload.Status,
		Service:   payload.Service,
		Timestamp: payload.Timestamp,
	}, nil
}

// CheckAuthorization is the resolver for the checkAuthorization field.
func (r *queryResolver) CheckAuthorization(ctx context.Context, input model.AuthCheckInput) (*model.AuthCheckResponse, error) {
	payload := map[string]any{
		"subject":  input.User,
		"resource": input.Object,
		"action":   input.Relation,
		"context": map[string]any{
			"relation": input.Relation,
		},
	}

	endpoint, err := joinEndpoint(r.PDPURL, "authorize")
	if err != nil {
		return nil, fmt.Errorf("build pdp authorize endpoint: %w", err)
	}

	body, statusCode, err := r.doJSONRequest(ctx, http.MethodPost, endpoint, payload)
	if err != nil {
		return nil, err
	}

	if statusCode == http.StatusForbidden {
		message := extractMessage(body, "forbidden")
		return &model.AuthCheckResponse{
			Success: true,
			Message: message,
			Allowed: false,
		}, nil
	}

	if statusCode >= 400 {
		message := extractMessage(body, fmt.Sprintf("pdp service returned status %d", statusCode))
		return nil, fmt.Errorf("authorization check failed: %s", message)
	}

	allowed := true
	message := "Authorization check completed"

	if len(body) > 0 {
		var payload struct {
			Allowed *bool  `json:"allowed"`
			Message string `json:"message"`
			Success *bool  `json:"success"`
		}
		if err := json.Unmarshal(body, &payload); err == nil {
			if payload.Allowed != nil {
				allowed = *payload.Allowed
			}
			if payload.Message != "" {
				message = payload.Message
			}
		}
	}

	return &model.AuthCheckResponse{
		Success: true,
		Message: message,
		Allowed: allowed,
	}, nil
}
