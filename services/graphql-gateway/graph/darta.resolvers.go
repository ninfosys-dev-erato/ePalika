package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.80

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"

	"git.ninjainfosys.com/ePalika/graphql-gateway/graph/model"
)

// RegisterDarta is the resolver for the registerDarta field.
func (r *mutationResolver) RegisterDarta(ctx context.Context, input model.RegisterDartaInput) (*model.RegisterDartaResponse, error) {
	payload := map[string]any{
		"title":       input.Title,
		"description": input.Description,
		"submittedBy": input.SubmittedBy,
	}

	endpoint, err := joinEndpoint(r.DartaChalaniURL, "register")
	if err != nil {
		return nil, fmt.Errorf("build darta register endpoint: %w", err)
	}

	body, statusCode, err := r.doJSONRequest(ctx, http.MethodPost, endpoint, payload)
	if err != nil {
		return nil, err
	}

	if statusCode == http.StatusNotFound || statusCode == http.StatusMethodNotAllowed {
		// Fallback to a more RESTful endpoint if the legacy one is unavailable.
		fallback, joinErr := joinEndpoint(r.DartaChalaniURL, "dartas")
		if joinErr == nil {
			body, statusCode, err = r.doJSONRequest(ctx, http.MethodPost, fallback, payload)
		}
		if err != nil {
			return nil, err
		}
	}

	if statusCode >= 400 {
		message := extractMessage(body, fmt.Sprintf("darta service returned status %d", statusCode))
		return nil, fmt.Errorf("darta register failed: %s", message)
	}

	response, parseErr := parseDartaRegisterResponse(body, input)
	if parseErr != nil {
		return nil, parseErr
	}

	return response, nil
}

// UpdateDartaStatus is the resolver for the updateDartaStatus field.
func (r *mutationResolver) UpdateDartaStatus(ctx context.Context, id string, status model.DartaStatus) (*model.UpdateDartaResponse, error) {
	payload := map[string]any{
		"status": status,
	}

	primaryEndpoint, err := joinEndpoint(r.DartaChalaniURL, "dartas", id)
	if err != nil {
		return nil, fmt.Errorf("build darta status endpoint: %w", err)
	}

	body, statusCode, err := r.doJSONRequest(ctx, http.MethodPatch, primaryEndpoint, payload)
	if err != nil {
		return nil, err
	}

	if statusCode == http.StatusNotFound || statusCode == http.StatusMethodNotAllowed {
		// Some deployments may expose a dedicated status endpoint.
		fallbackEndpoint, joinErr := joinEndpoint(r.DartaChalaniURL, "dartas", id, "status")
		if joinErr == nil {
			body, statusCode, err = r.doJSONRequest(ctx, http.MethodPatch, fallbackEndpoint, payload)
		}
		if err != nil {
			return nil, err
		}
	}

	if statusCode == http.StatusNotFound {
		return nil, fmt.Errorf("darta %s not found", id)
	}
	if statusCode >= 400 {
		message := extractMessage(body, fmt.Sprintf("darta service returned status %d", statusCode))
		return nil, fmt.Errorf("failed to update darta status: %s", message)
	}

	resp, parseErr := parseDartaMutationResponse(body, status)
	if parseErr != nil {
		return nil, parseErr
	}

	return resp, nil
}

// DartaChalaniHealth is the resolver for the dartaChalaniHealth field.
func (r *queryResolver) DartaChalaniHealth(ctx context.Context) (*model.HealthStatus, error) {
	endpoint, err := joinEndpoint(r.DartaChalaniURL, "health")
	if err != nil {
		return nil, fmt.Errorf("build darta health endpoint: %w", err)
	}

	body, statusCode, err := r.doJSONRequest(ctx, http.MethodGet, endpoint, nil)
	if err != nil {
		return &model.HealthStatus{Status: "unhealthy", Service: "darta-chalani"}, nil
	}

	timestamp := time.Now().UTC().Format(time.RFC3339)
	if statusCode >= 400 {
		return &model.HealthStatus{
			Status:    "unhealthy",
			Service:   "darta-chalani",
			Timestamp: &timestamp,
		}, nil
	}

	var payload struct {
		Status    string  `json:"status"`
		Service   string  `json:"service"`
		Timestamp *string `json:"timestamp"`
	}
	if err := json.Unmarshal(body, &payload); err != nil {
		return &model.HealthStatus{Status: "healthy", Service: "darta-chalani", Timestamp: &timestamp}, nil
	}

	if payload.Status == "" {
		payload.Status = "healthy"
	}
	if payload.Service == "" {
		payload.Service = "darta-chalani"
	}
	if payload.Timestamp == nil {
		payload.Timestamp = &timestamp
	}

	return &model.HealthStatus{
		Status:    payload.Status,
		Service:   payload.Service,
		Timestamp: payload.Timestamp,
	}, nil
}

// GetDarta is the resolver for the getDarta field.
func (r *queryResolver) GetDarta(ctx context.Context, id string) (*model.Darta, error) {
	endpoint, err := joinEndpoint(r.DartaChalaniURL, "dartas", id)
	if err != nil {
		return nil, fmt.Errorf("build darta get endpoint: %w", err)
	}

	body, statusCode, err := r.doJSONRequest(ctx, http.MethodGet, endpoint, nil)
	if err != nil {
		return nil, err
	}

	if statusCode == http.StatusNotFound {
		return nil, nil
	}
	if statusCode >= 400 {
		message := extractMessage(body, fmt.Sprintf("darta service returned status %d", statusCode))
		return nil, fmt.Errorf("get darta failed: %s", message)
	}

	dto, parseErr := parseSingleDartaPayload(body)
	if parseErr != nil {
		return nil, parseErr
	}

	darta, convErr := dto.toModel("", "", "", model.DartaStatusPending)
	if convErr != nil {
		return nil, convErr
	}

	return darta, nil
}

// ListDartas is the resolver for the listDartas field.
func (r *queryResolver) ListDartas(ctx context.Context, limit *int, offset *int) (*model.DartaList, error) {
	resolvedLimit := defaultInt(limit, 10)
	resolvedOffset := defaultInt(offset, 0)

	endpoint, err := joinEndpoint(r.DartaChalaniURL, "dartas")
	if err != nil {
		return nil, fmt.Errorf("build darta list endpoint: %w", err)
	}

	parsedURL, err := url.Parse(endpoint)
	if err != nil {
		return nil, fmt.Errorf("parse darta list url: %w", err)
	}

	query := parsedURL.Query()
	query.Set("limit", strconv.Itoa(resolvedLimit))
	query.Set("offset", strconv.Itoa(resolvedOffset))
	parsedURL.RawQuery = query.Encode()

	body, statusCode, err := r.doJSONRequest(ctx, http.MethodGet, parsedURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if statusCode >= 400 {
		message := extractMessage(body, fmt.Sprintf("darta service returned status %d", statusCode))
		return nil, fmt.Errorf("list dartas failed: %s", message)
	}

	list, parseErr := parseDartaListResponse(body, resolvedLimit, resolvedOffset)
	if parseErr != nil {
		return nil, parseErr
	}

	return list, nil
}

// Helper types and functions -------------------------------------------------

type dartaDTO struct {
	ID          string  `json:"id"`
	Title       string  `json:"title"`
	Description string  `json:"description"`
	SubmittedBy string  `json:"submittedBy"`
	Status      string  `json:"status"`
	CreatedAt   string  `json:"createdAt"`
	UpdatedAt   *string `json:"updatedAt"`
}

type dartaRegisterAPIResponse struct {
	Success bool      `json:"success"`
	Message string    `json:"message"`
	DartaID *string   `json:"dartaId"`
	Darta   *dartaDTO `json:"darta"`
	Data    *dartaDTO `json:"data"`
}

type dartaMutationAPIResponse struct {
	Success bool      `json:"success"`
	Message string    `json:"message"`
	Darta   *dartaDTO `json:"darta"`
	Data    *dartaDTO `json:"data"`
}

type dartaListData struct {
	Items  []*dartaDTO `json:"items"`
	Total  *int        `json:"total"`
	Limit  *int        `json:"limit"`
	Offset *int        `json:"offset"`
}

type dartaListAPIResponse struct {
	Success bool           `json:"success"`
	Message string         `json:"message"`
	Data    *dartaListData `json:"data"`
	Items   []*dartaDTO    `json:"items"`
	Total   *int           `json:"total"`
	Limit   *int           `json:"limit"`
	Offset  *int           `json:"offset"`
}

func parseDartaRegisterResponse(body []byte, input model.RegisterDartaInput) (*model.RegisterDartaResponse, error) {
	var payload dartaRegisterAPIResponse
	if err := json.Unmarshal(body, &payload); err != nil {
		return nil, fmt.Errorf("parse darta register response: %w", err)
	}

	dto := firstNonNilDarta(payload.Darta, payload.Data)
	if dto == nil {
		return nil, fmt.Errorf("darta register response missing darta payload")
	}

	darta, err := dto.toModel(input.Title, input.Description, input.SubmittedBy, model.DartaStatusPending)
	if err != nil {
		return nil, err
	}

	response := &model.RegisterDartaResponse{
		Success: payload.Success,
		Message: defaultString(payload.Message, "Darta registered successfully"),
		Darta:   darta,
	}

	if payload.DartaID != nil && strings.TrimSpace(*payload.DartaID) != "" {
		response.DartaID = payload.DartaID
	} else if darta.ID != "" {
		idCopy := darta.ID
		response.DartaID = &idCopy
	}

	return response, nil
}

func parseDartaMutationResponse(body []byte, fallbackStatus model.DartaStatus) (*model.UpdateDartaResponse, error) {
	var payload dartaMutationAPIResponse
	if err := json.Unmarshal(body, &payload); err != nil {
		return nil, fmt.Errorf("parse darta update response: %w", err)
	}

	dto := firstNonNilDarta(payload.Darta, payload.Data)
	if dto == nil {
		return nil, fmt.Errorf("darta update response missing darta payload")
	}

	darta, err := dto.toModel("", "", "", fallbackStatus)
	if err != nil {
		return nil, err
	}

	return &model.UpdateDartaResponse{
		Success: payload.Success,
		Message: defaultString(payload.Message, fmt.Sprintf("Status updated to %s", fallbackStatus)),
		Darta:   darta,
	}, nil
}

func parseSingleDartaPayload(body []byte) (*dartaDTO, error) {
	var wrapper struct {
		Data  *dartaDTO `json:"data"`
		Darta *dartaDTO `json:"darta"`
	}
	if err := json.Unmarshal(body, &wrapper); err == nil {
		if wrapper.Data != nil {
			return wrapper.Data, nil
		}
		if wrapper.Darta != nil {
			return wrapper.Darta, nil
		}
	}

	var dto dartaDTO
	if err := json.Unmarshal(body, &dto); err == nil {
		if dto == (dartaDTO{}) {
			return nil, fmt.Errorf("empty darta payload")
		}
		return &dto, nil
	}

	return nil, fmt.Errorf("unable to decode darta payload")
}

func parseDartaListResponse(body []byte, fallbackLimit, fallbackOffset int) (*model.DartaList, error) {
	var payload dartaListAPIResponse
	if err := json.Unmarshal(body, &payload); err != nil {
		return nil, fmt.Errorf("parse darta list response: %w", err)
	}

	data := payload.Data
	if data == nil {
		data = &dartaListData{
			Items:  payload.Items,
			Total:  payload.Total,
			Limit:  payload.Limit,
			Offset: payload.Offset,
		}
	} else {
		if len(data.Items) == 0 && len(payload.Items) > 0 {
			data.Items = payload.Items
		}
		if data.Total == nil && payload.Total != nil {
			data.Total = payload.Total
		}
		if data.Limit == nil && payload.Limit != nil {
			data.Limit = payload.Limit
		}
		if data.Offset == nil && payload.Offset != nil {
			data.Offset = payload.Offset
		}
	}

	items := make([]*model.Darta, 0, len(data.Items))
	for _, dto := range data.Items {
		darta, err := dto.toModel("", "", "", model.DartaStatusPending)
		if err != nil {
			return nil, fmt.Errorf("invalid darta item: %w", err)
		}
		items = append(items, darta)
	}

	total := len(items)
	if data.Total != nil {
		total = *data.Total
	}
	limit := fallbackLimit
	if data.Limit != nil {
		limit = *data.Limit
	}
	offset := fallbackOffset
	if data.Offset != nil {
		offset = *data.Offset
	}

	return &model.DartaList{
		Items:  items,
		Total:  total,
		Limit:  limit,
		Offset: offset,
	}, nil
}

func (dto *dartaDTO) toModel(fallbackTitle, fallbackDescription, fallbackSubmitted string, fallbackStatus model.DartaStatus) (*model.Darta, error) {
	if dto == nil {
		return nil, fmt.Errorf("nil darta payload")
	}

	id := strings.TrimSpace(dto.ID)
	if id == "" {
		return nil, fmt.Errorf("darta payload missing id")
	}

	title := defaultString(dto.Title, fallbackTitle)
	if title == "" {
		return nil, fmt.Errorf("darta payload missing title")
	}

	description := defaultString(dto.Description, fallbackDescription)
	if description == "" {
		return nil, fmt.Errorf("darta payload missing description")
	}

	submittedBy := defaultString(dto.SubmittedBy, fallbackSubmitted)
	if submittedBy == "" {
		return nil, fmt.Errorf("darta payload missing submittedBy")
	}

	status := parseDartaStatus(dto.Status, fallbackStatus)

	createdAt := dto.CreatedAt
	if strings.TrimSpace(createdAt) == "" {
		createdAt = time.Now().UTC().Format(time.RFC3339)
	}

	return &model.Darta{
		ID:          id,
		Title:       title,
		Description: description,
		SubmittedBy: submittedBy,
		Status:      status,
		CreatedAt:   createdAt,
		UpdatedAt:   dto.UpdatedAt,
	}, nil
}

func parseDartaStatus(value string, fallback model.DartaStatus) model.DartaStatus {
	switch strings.ToUpper(strings.TrimSpace(value)) {
	case string(model.DartaStatusPending):
		return model.DartaStatusPending
	case string(model.DartaStatusInProgress):
		return model.DartaStatusInProgress
	case string(model.DartaStatusApproved):
		return model.DartaStatusApproved
	case string(model.DartaStatusRejected):
		return model.DartaStatusRejected
	case string(model.DartaStatusCompleted):
		return model.DartaStatusCompleted
	default:
		if fallback != "" {
			return fallback
		}
		return model.DartaStatusPending
	}
}

func defaultString(primary, fallback string) string {
	if strings.TrimSpace(primary) != "" {
		return primary
	}
	return fallback
}

func firstNonNilDarta(primary, secondary *dartaDTO) *dartaDTO {
	if primary != nil {
		return primary
	}
	return secondary
}

func defaultInt(value *int, fallback int) int {
	if value != nil {
		return *value
	}
	return fallback
}
