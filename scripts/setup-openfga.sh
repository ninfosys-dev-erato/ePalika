#!/usr/bin/env bash
set -euo pipefail

###
# setup-openfga.sh â€” robust OpenFGA bootstrapper
# - Normalizes your model.json into OpenFGA's expected shape
# - Creates a store, uploads the model, seeds a few tuples
# - Writes FGA_STORE_ID and FGA_MODEL_ID into .env
#
# Env vars you can override:
#   OPENFGA_API_URL            (default: http://localhost:8081)
#   MODEL_FILE                 (default: <repo>/policies/openfga/models/model.json)
#   ENV_FILE                   (default: <repo>/.env)
#   OPENFGA_BEARER_TOKEN       (optional)
#   OPENFGA_STORE_NAME         (default: epalika)
###

# ---------- Config & Paths ----------
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"

OPENFGA_API_URL="${OPENFGA_API_URL:-http://localhost:8081}"   # your instance is on 8081
MODEL_FILE="${MODEL_FILE:-${PROJECT_ROOT}/policies/openfga/models/model.json}"
ENV_FILE="${ENV_FILE:-${PROJECT_ROOT}/.env}"
OPENFGA_BEARER_TOKEN="${OPENFGA_BEARER_TOKEN:-}"
OPENFGA_STORE_NAME="${OPENFGA_STORE_NAME:-epalika}"

# ---------- Logging ----------
BOLD="" RESET="" YELLOW="" GREEN="" RED=""
if command -v tput >/dev/null 2>&1; then
  BOLD="$(tput bold)"; RESET="$(tput sgr0)"
  YELLOW="$(tput setaf 3)"; GREEN="$(tput setaf 2)"; RED="$(tput setaf 1)"
fi
log()  { echo -e "${BOLD}$*${RESET}"; }
info() { echo -e "  ${YELLOW}â€¢${RESET} $*"; }
ok()   { echo -e "  ${GREEN}âœ“${RESET} $*"; }
err()  { echo -e "  ${RED}âœ—${RESET} $*" >&2; }

# ---------- Preconditions ----------
for tool in curl jq awk mktemp; do
  command -v "$tool" >/dev/null 2>&1 || { err "required tool '$tool' not found"; exit 1; }
done

# ---------- HTTP Helpers ----------
AUTH_HEADER=()
if [[ -n "$OPENFGA_BEARER_TOKEN" ]]; then
  AUTH_HEADER=(-H "Authorization: Bearer ${OPENFGA_BEARER_TOKEN}")
fi

curl_json() {
  # usage: curl_json METHOD URL [DATA_JSON]
  local method="$1"
  local url="$2"
  local data="${3:-}"
  if [[ -n "$data" ]]; then
    curl -sS --fail-with-body -X "$method" "$url" \
      -H "Content-Type: application/json" "${AUTH_HEADER[@]}" \
      --data "$data"
  else
    curl -sS --fail-with-body -X "$method" "$url" \
      -H "Content-Type: application/json" "${AUTH_HEADER[@]}"
  fi
}

# ---------- .env Helpers ----------
ensure_env_file() {
  local file="$1"
  mkdir -p "$(dirname "$file")"
  if [[ ! -f "$file" ]]; then
    {
      echo "# OpenFGA Configuration"
      echo "# Generated by setup-openfga.sh on $(date)"
      echo
    } > "$file"
  elif [[ -s "$file" ]] && [[ "$(tail -c 1 "$file" 2>/dev/null || true)" != $'\n' ]]; then
    echo >> "$file"
  fi
}

upsert_env_var() {
  local file="$1" key="$2" value="$3"
  ensure_env_file "$file"

  local tmp
  tmp="$(mktemp "${file}.XXXXXX")"

  awk -v search_key="$key" -v search_value="$value" '
    BEGIN { updated = 0 }
    $0 ~ ("^" search_key "=") { print search_key "=" search_value; updated = 1; next }
    { print }
    END { if (!updated) print search_key "=" search_value }
  ' "$file" > "$tmp"

  mv "$tmp" "$file"
}

# ---------- Model Normalizer ----------
# Accepts any of:
#   1) { "type_definitions": [...], "schema_version": "1.1", "conditions": {...}? }
#   2) { "authorization_model": { "type_definitions": [...], "schema_version": "1.1" } }
#   3) [ ...type_definitions... ]  (array)
normalize_model() {
  local file="$1"
  jq -c '
    if has("type_definitions") then
      {
        type_definitions: .type_definitions,
        schema_version: (.schema_version // .schemaVersion // "1.1")
      }
      + (if has("conditions") then {conditions: .conditions} else {} end)
    elif has("authorization_model") then
      .authorization_model
      | {
          type_definitions: .type_definitions,
          schema_version: (.schema_version // .schemaVersion // "1.1")
        }
      + (if has("conditions") then {conditions: .conditions} else {} end)
    elif type == "array" then
      { type_definitions: ., schema_version: "1.1" }
    else
      error("Unrecognized model format. Expected: {type_definitions,...} or {authorization_model:{...}} or an array.")
    end
  ' "$file"
}

# ---------- Start ----------
log "ğŸš€ Setting up OpenFGA"
info "API URL:     ${OPENFGA_API_URL}"
info "Model file:  ${MODEL_FILE}"
info "Env file:    ${ENV_FILE}"
info "Store name:  ${OPENFGA_STORE_NAME}"
if [[ -n "$OPENFGA_BEARER_TOKEN" ]]; then info "Auth:         Bearer token (set)"; fi
echo

# Create .env early so failures leave breadcrumbs
ensure_env_file "$ENV_FILE"

# Validate model file exists + JSON
[[ -f "$MODEL_FILE" ]] || { err "model file not found at ${MODEL_FILE}"; exit 1; }
jq empty "$MODEL_FILE" >/dev/null 2>&1 || { err "model file is not valid JSON"; exit 1; }
ok "Model file validated"

# Health check (up to 30s)
info "Waiting for OpenFGA to be ready..."
for i in {1..30}; do
  if curl -sSf "${OPENFGA_API_URL}/healthz" >/dev/null 2>&1; then
    ok "OpenFGA is ready"
    break
  fi
  if [[ $i -eq 30 ]]; then
    err "OpenFGA not responding after 30s. Is it running? (try: docker compose ps openfga)"
    exit 1
  fi
  sleep 1
done

# Create store
echo
info "Creating OpenFGA storeâ€¦"
STORE_RESPONSE="$(curl_json POST "${OPENFGA_API_URL}/stores" "$(jq -nc --arg n "$OPENFGA_STORE_NAME" '{name:$n}')" 2> >(tee /tmp/openfga_store_err.log >&2))" || {
  err "failed to create store. Server said:"
  if jq -e . >/dev/null 2>&1 < /tmp/openfga_store_err.log; then
    jq . < /tmp/openfga_store_err.log
  else
    cat /tmp/openfga_store_err.log
  fi
  exit 1
}
STORE_ID="$(echo "$STORE_RESPONSE" | jq -r '.id // empty')"
[[ -n "$STORE_ID" ]] || { err "could not extract store id. response: $STORE_RESPONSE"; exit 1; }
ok "Store ID: ${STORE_ID}"

# Upload authorization model (normalized)
echo
info "Normalizing and uploading authorization modelâ€¦"
MODEL_PAYLOAD="$(normalize_model "$MODEL_FILE")" || { err "failed to normalize model from: $MODEL_FILE"; exit 1; }

info "Normalized payload summary:"
echo "$MODEL_PAYLOAD" | jq -c '{schema_version, type_def_count: (.type_definitions|length), has_conditions: has("conditions")}' || true

MODEL_RESPONSE="$(curl_json POST "${OPENFGA_API_URL}/stores/${STORE_ID}/authorization-models" "$MODEL_PAYLOAD" 2> >(tee /tmp/openfga_model_err.log >&2))" || {
  err "OpenFGA rejected the model. Server said:"
  if jq -e . >/dev/null 2>&1 < /tmp/openfga_model_err.log; then
    jq . < /tmp/openfga_model_err.log
  else
    cat /tmp/openfga_model_err.log
  fi
  exit 1
}
MODEL_ID="$(echo "$MODEL_RESPONSE" | jq -r '.authorization_model_id // empty')"
[[ -n "$MODEL_ID" ]] || { err "could not extract authorization_model_id. response: $MODEL_RESPONSE"; exit 1; }
ok "Authorization model ID: ${MODEL_ID}"

# Seed tuples (non-fatal)
echo
info "Writing initial tuplesâ€¦"
if curl_json POST "${OPENFGA_API_URL}/stores/${STORE_ID}/write" '{
  "writes": {
    "tuple_keys": [
      {"user":"user:admin","relation":"admin","object":"tenant:default"},
      {"user":"tenant:default","relation":"tenant","object":"graphql:query"},
      {"user":"tenant:default","relation":"tenant","object":"service:darta"},
      {"user":"tenant:default","relation":"tenant","object":"service:identity"}
    ]
  }
}' >/dev/null 2>&1; then
  ok "Initial tuples created"
else
  echo "  (warning) failed to write initial tuples; continuingâ€¦"
fi

# Persist to .env
echo
info "Updating ${ENV_FILE}â€¦"
upsert_env_var "$ENV_FILE" "FGA_STORE_ID" "$STORE_ID"
upsert_env_var "$ENV_FILE" "FGA_MODEL_ID" "$MODEL_ID"
ok "Wrote FGA_STORE_ID and FGA_MODEL_ID to ${ENV_FILE}"

# Summary
echo
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo "âœ… OpenFGA setup complete"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo "Store ID : ${STORE_ID}"
echo "Model ID : ${MODEL_ID}"
echo
echo "ğŸ“Œ Saved in: ${ENV_FILE}"
echo
echo "ğŸ§ª Quick check:"
echo "curl -sS -X POST ${OPENFGA_API_URL}/stores/${STORE_ID}/check \\"
echo "  -H 'Content-Type: application/json' ${OPENFGA_BEARER_TOKEN:+-H 'Authorization: Bearer ***'} \\"
echo "  -d '{\"tuple_key\":{\"user\":\"user:admin\",\"relation\":\"admin\",\"object\":\"tenant:default\"}}' | jq"
